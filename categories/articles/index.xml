<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on Marcos Azevedo (aka psylinux)</title><link>https://psylinux.github.io/categories/articles/</link><description>Recent content in Articles on Marcos Azevedo (aka psylinux)</description><generator>Hugo</generator><language>en-us</language><copyright>2025 Marcos Azevedo</copyright><lastBuildDate>Sun, 13 Jan 2019 17:38:15 -0300</lastBuildDate><atom:link href="https://psylinux.github.io/categories/articles/index.xml" rel="self" type="application/rss+xml"/><item><title>Article :: Debugging with strace</title><link>https://psylinux.github.io/articles/article_debugging_with_strace/</link><pubDate>Sun, 13 Jan 2019 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/articles/article_debugging_with_strace/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>By the end of this article, you&amp;rsquo;ll understand how to use strace to debug programs without access to source code, trace system calls, and troubleshoot execution issues in Linux.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>Debugging without source code can feel like solving a puzzle in the dark. Strace shines a light by showing you exactly what system calls a program makes, from opening files to network connections. Whether you&amp;rsquo;re troubleshooting a crash, investigating suspicious behavior, or just curious about how a program works under the hood, strace is an essential tool in your Linux toolkit.&lt;/p></description></item><item><title>Article :: Using the Linux Syscalls in Assembly</title><link>https://psylinux.github.io/articles/article_linux_syscalls_in_assembly/</link><pubDate>Fri, 28 Dec 2018 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/articles/article_linux_syscalls_in_assembly/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This hands-on tutorial teaches you how to write assembly programs that invoke Linux system calls directly, bypassing the C library and interacting with the kernel at the lowest level.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>When a program needs to interact with the operating system; to write to a file, allocate memory, or exit gracefully; it makes a &lt;strong>system call&lt;/strong> (syscall). Most programmers use these indirectly through C library wrappers, but understanding how to invoke syscalls directly from assembly gives you deep insight into how programs actually work.&lt;/p></description></item><item><title>Article :: Getting Started with GDB</title><link>https://psylinux.github.io/articles/article_getting_start_with_gdb/</link><pubDate>Sun, 16 Dec 2018 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/articles/article_getting_start_with_gdb/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This comprehensive guide covers everything you need to start debugging C programs with GDB, from compiling with debug symbols to inspecting memory and controlling program execution.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>GDB (GNU Debugger) is the standard debugger for programs compiled with GCC. Unlike tools like strace that show system calls, GDB lets you step through your source code line by line, inspect variables, set conditional breakpoints, and even modify program behavior during execution.&lt;/p></description></item></channel></rss>