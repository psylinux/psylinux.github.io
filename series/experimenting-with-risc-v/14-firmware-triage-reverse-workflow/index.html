<!doctype html><html lang=en-us data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Firmware Triage and Reverse Engineering Workflow - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Marcos Azevedo Blog"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Primary navigation"><a class="me-2 fs-4" href=/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Home</span>
</a><a class="mx-2 fs-4" href=/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Search</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Language><span class=fw-semibold>English</span>
<a href=/pt/series/experimenting-with-risc-v/14-firmware-triage-reverse-workflow/>Português</a></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Firmware Triage and Reverse Engineering Workflow</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
5 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#1-firmware-file-types-what-you-might-get>1. Firmware file types: what you might get</a><ul><li><a href=#common-formats>Common formats</a></li><li><a href=#a-core-reality>A core reality</a></li></ul></li><li><a href=#2-the-triage-checklist-do-this-every-time>2. The triage checklist (do this every time)</a><ul><li><a href=#step-1-identify-the-file-type>Step 1: Identify the file type</a></li><li><a href=#step-2-quick-entropystructure-sense>Step 2: Quick entropy/structure sense</a></li><li><a href=#step-3-search-for-signatures>Step 3: Search for signatures</a></li><li><a href=#step-4-if-elf-extract-structure-immediately>Step 4: If ELF: extract structure immediately</a></li></ul></li><li><a href=#3-if-you-have-a-bin-how-to-recover-likely-load-address>3. If you have a .bin: how to recover likely load address</a><ul><li><a href=#strategy-a-from-the-platform-memory-map>Strategy A: From the platform memory map</a></li><li><a href=#strategy-b-from-vector-tables--reset-patterns>Strategy B: From vector tables / reset patterns</a></li><li><a href=#strategy-c-from-absolute-addresses-in-code>Strategy C: From absolute addresses in code</a></li></ul></li><li><a href=#4-a-practical-first-disassembly-approach-without-committing-too-early>4. A practical “first disassembly” approach (without committing too early)</a><ul><li><a href=#example-disassemble-a-raw-binary-as-rv32>Example: disassemble a raw binary as RV32</a></li></ul></li><li><a href=#5-carving-extracting-sub-images-from-a-blob>5. Carving: extracting sub-images from a blob</a></li><li><a href=#6-turning-findings-into-a-map-the-most-underrated-skill>6. Turning findings into a map (the most underrated skill)</a></li><li><a href=#7-minimal-firmware-style-practice-lab-using-your-own-sample>7. Minimal “firmware-style” practice lab (using your own sample)</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#how-to-test-your-answers>How to test your answers</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></div><h2 id=tldr>TL;DR</h2><ul><li>You’ll learn a practical workflow to go from an unknown firmware file (<code>.bin</code>, <code>.img</code>, <code>.fw</code>, sometimes <code>.elf</code>) to a structured understanding:<ul><li>identify file type and architecture,</li><li>locate code/data boundaries,</li><li>recover load addresses and entry points,</li><li>and choose the right next tools (disassembly, decompilation, emulation, or QEMU tracing).</li></ul></li><li>You’ll practice <strong>repeatable triage</strong> steps that work well for embedded targets (including RISC-V).</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>Reverse engineering firmware is most successful when you treat it like an investigation with checkpoints, not a “click around in a disassembler” activity.</div><hr><h2 id=1-firmware-file-types-what-you-might-get>1. Firmware file types: what you might get</h2><h3 id=common-formats>Common formats</h3><ul><li><strong>ELF</strong>: best case (symbols, sections, entry point may exist)</li><li><strong>Raw binary (<code>.bin</code>)</strong>: flat bytes, no addresses</li><li><strong>Container images</strong>: may embed file systems or multiple partitions (e.g., update bundles)</li><li><strong>Compressed blobs</strong>: LZMA, gzip, etc.</li></ul><h3 id=a-core-reality>A core reality</h3><p>A raw binary does <strong>not</strong> tell you:</p><ul><li>where it loads in memory</li><li>where execution starts</li><li>what architecture it is</li></ul><p>You must infer these from context.</p><hr><h2 id=2-the-triage-checklist-do-this-every-time>2. The triage checklist (do this every time)</h2><h3 id=step-1-identify-the-file-type>Step 1: Identify the file type</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>file firmware.bin
</span></span></code></pre></td></tr></table></div></div><p>If it’s ELF, you’re in a much easier situation.</p><h3 id=step-2-quick-entropystructure-sense>Step 2: Quick entropy/structure sense</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hexdump -C firmware.bin | head
</span></span><span style=display:flex><span>strings -a firmware.bin | head
</span></span></code></pre></td></tr></table></div></div><p>Look for:</p><ul><li>ASCII strings (boot messages, paths, version)</li><li>magic bytes (e.g., <code>7f 45 4c 46</code> for ELF)</li><li>long runs of <code>00</code> or <code>ff</code> (often padding/erased flash)</li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>If <code>strings</code> returns lots of readable paths like <code>/etc/</code> or <code>/bin/</code>, you may be looking at an embedded Linux filesystem image.</div><h3 id=step-3-search-for-signatures>Step 3: Search for signatures</h3><p>Even without specialized tools you can search for patterns:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep -aobU <span style=color:#e6db74>$&#39;\x7fELF&#39;</span> firmware.bin | head
</span></span></code></pre></td></tr></table></div></div><p>This tells you if an ELF is embedded inside a larger blob.</p><h3 id=step-4-if-elf-extract-structure-immediately>Step 4: If ELF: extract structure immediately</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -h firmware.elf
</span></span><span style=display:flex><span>readelf -S firmware.elf
</span></span><span style=display:flex><span>readelf -l firmware.elf
</span></span><span style=display:flex><span>readelf -s firmware.elf | head
</span></span></code></pre></td></tr></table></div></div><p>Key questions:</p><ul><li>Is it <strong>ELF32</strong> or <strong>ELF64</strong>?</li><li>Machine = <strong>RISC-V</strong>?</li><li>What is the <strong>entry point</strong>?</li><li>Which segments are loadable (<code>PT_LOAD</code>)?</li></ul><hr><h2 id=3-if-you-have-a-bin-how-to-recover-likely-load-address>3. If you have a .bin: how to recover likely load address</h2><h3 id=strategy-a-from-the-platform-memory-map>Strategy A: From the platform memory map</h3><p>If you know the target memory map (for example, QEMU <code>virt</code>), you often know typical RAM/flash addresses.</p><ul><li>Many RV32 bare-metal examples start around <code>0x80000000</code> for RAM on QEMU virt.</li><li>Real SoCs vary wildly-use datasheets or boot logs.</li></ul><h3 id=strategy-b-from-vector-tables--reset-patterns>Strategy B: From vector tables / reset patterns</h3><p>On some architectures, the reset vector has a recognizable structure. On RISC-V, boot code often begins with a small prologue and jumps; patterns are less standardized than ARM vector tables, but you can still hunt for:</p><ul><li>plausible prologue sequences</li><li>references to known MMIO regions</li></ul><h3 id=strategy-c-from-absolute-addresses-in-code>Strategy C: From absolute addresses in code</h3><p>If the firmware includes absolute addresses (MMIO registers, RAM ranges), those addresses can reveal the platform.</p><ul><li>Scan for aligned 32-bit values that look like addresses (e.g., high bits consistent)</li></ul><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>This is where ELF knowledge helps: once you guess a base address, you can test whether disassembly “starts making sense”.</div><hr><h2 id=4-a-practical-first-disassembly-approach-without-committing-too-early>4. A practical “first disassembly” approach (without committing too early)</h2><p>Even without a GUI tool, you can do a sanity disassembly pass if you know the architecture.</p><h3 id=example-disassemble-a-raw-binary-as-rv32>Example: disassemble a raw binary as RV32</h3><p>If you have GNU binutils that support RISC-V:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -D -b binary -m riscv:rv32 firmware.bin | less
</span></span></code></pre></td></tr></table></div></div><p>If the output is mostly illegal/garbage instructions, your assumptions might be wrong:</p><ul><li>wrong arch (rv64 vs rv32)</li><li>wrong endianness (rare for RISC-V)</li><li>wrong base address assumptions (for relative branches, this matters)</li></ul><div class="alert alert-warning my-4" role=alert><div class="fw-bold mb-2">Warning</div><code>objdump -b binary</code> does not know the correct load address. Disassembly is “addressed” from 0 unless you compensate in your analysis tooling.</div><hr><h2 id=5-carving-extracting-sub-images-from-a-blob>5. Carving: extracting sub-images from a blob</h2><p>If you find an embedded ELF at offset <code>O</code>, extract it:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>firmware.bin of<span style=color:#f92672>=</span>extracted.elf bs<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> skip<span style=color:#f92672>=</span>$O
</span></span><span style=display:flex><span>file extracted.elf
</span></span></code></pre></td></tr></table></div></div><p>If it’s a real ELF, you can now use all Chapter 2 methods.</p><p>If you find a filesystem or compression signature, you may need specialized tools (common in firmware work), but the workflow stays:</p><ul><li>identify</li><li>extract</li><li>validate</li></ul><hr><h2 id=6-turning-findings-into-a-map-the-most-underrated-skill>6. Turning findings into a map (the most underrated skill)</h2><p>Create a simple analysis note like:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Firmware X
</span></span><span style=display:flex><span>- size: ...
</span></span><span style=display:flex><span>- type: ...
</span></span><span style=display:flex><span>- possible arch: rv32im
</span></span><span style=display:flex><span>- strings: ...
</span></span><span style=display:flex><span>- suspected load address: ...
</span></span><span style=display:flex><span>- suspected entry point: ...
</span></span><span style=display:flex><span>- notable constants: ...
</span></span><span style=display:flex><span>- next action: (emulate / disassemble / find UART logs / look for update format)
</span></span></code></pre></td></tr></table></div></div><p>This makes your work reproducible and easier to share.</p><hr><h2 id=7-minimal-firmware-style-practice-lab-using-your-own-sample>7. Minimal “firmware-style” practice lab (using your own sample)</h2><ol><li>Take <code>build/ld_demo.elf</code> (from Chapter 7) and convert it to <code>.bin</code>.</li><li>Pretend you don’t know what it is.</li><li>Use only <code>file</code>, <code>hexdump</code>, <code>strings</code>, and <code>objdump -b binary</code> to identify it.</li><li>Write down your best guess about:<ul><li>architecture,</li><li>load address,</li><li>what the code does.</li></ul></li></ol><p>Then compare with the truth using <code>readelf</code> on the original ELF.</p><hr><h2 id=exercises>Exercises</h2><ol><li>Embed an ELF into a larger blob (e.g., by concatenating with padding) and practice carving it out using <code>grep -aob</code> and <code>dd</code>.</li><li>Create a raw binary with a known base address assumption (e.g., your linker origin) and see how your disassembly changes if you assume the wrong base.</li><li>Pick 5 strings from a firmware image and write hypotheses about what subsystems they relate to.</li></ol><h3 id=how-to-test-your-answers>How to test your answers</h3><ul><li>You can produce a short “analysis map” that someone else could follow.</li><li>Your extracted sub-images validate with <code>file</code> and <code>readelf</code> (when applicable).</li></ul><hr><h2 id=summary>Summary</h2><p>You learned a repeatable firmware triage workflow: identify → extract → validate → map → choose next analysis step.</p><p>Next: <strong>dynamic analysis with Frida (Dynamic Instrumentation Toolkit)</strong>-when it applies to IoT/firmware, what constraints exist, and how to do safe, reproducible hooking experiments.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/series/experimenting-with-risc-v/13-floats-endianness-bitpacking/ data-toggle=tooltip data-placement=top title="Floating Point, Endianness, and Bit-Packing (Verifying with Python)"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/series/experimenting-with-risc-v/15-dynamic-analysis-frida/ data-toggle=tooltip data-placement=top title="Dynamic Analysis with QEMU Tracing"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>