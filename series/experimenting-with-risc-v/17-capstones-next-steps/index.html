<!doctype html><html lang=en-us data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Capstones and Next Steps - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Marcos Azevedo Blog"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Primary navigation"><a class="me-2 fs-4" href=/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Home</span>
</a><a class="mx-2 fs-4" href=/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Search</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Language><span class=fw-semibold>English</span>
<a href=/pt/series/experimenting-with-risc-v/17-capstones-next-steps/>Português</a></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Capstones and Next Steps</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
4 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#capstone-1-rv32-binaryisc---a-tiny-firmware-monitor-in-qemu>Capstone 1: RV32 “binaryISC” - a tiny firmware monitor in QEMU</a><ul><li><a href=#goal>Goal</a></li><li><a href=#deliverables>Deliverables</a></li><li><a href=#suggested-implementation-sketch>Suggested implementation sketch</a></li><li><a href=#test-plan>Test plan</a></li><li><a href=#stretch-goals>Stretch goals</a></li></ul></li><li><a href=#capstone-2-c--assembly-explanation-pack-teaching-deliverable>Capstone 2: “C → Assembly” explanation pack (teaching deliverable)</a><ul><li><a href=#goal-1>Goal</a></li><li><a href=#deliverables-1>Deliverables</a></li><li><a href=#test-plan-1>Test plan</a></li></ul></li><li><a href=#capstone-3-firmware-triage-report-static-first>Capstone 3: Firmware triage report (static-first)</a><ul><li><a href=#goal-2>Goal</a></li><li><a href=#deliverables-2>Deliverables</a></li><li><a href=#test-plan-2>Test plan</a></li></ul></li><li><a href=#capstone-4-dynamic-analysis-mini-lab-frida>Capstone 4: Dynamic analysis mini-lab (Frida)</a><ul><li><a href=#goal-3>Goal</a></li><li><a href=#deliverables-3>Deliverables</a></li><li><a href=#stretch-goals-1>Stretch goals</a></li></ul></li><li><a href=#capstone-5-hardware-validation-worksheet-uartspii2c>Capstone 5: Hardware validation worksheet (UART/SPI/I2C)</a><ul><li><a href=#goal-4>Goal</a></li><li><a href=#deliverables-4>Deliverables</a></li><li><a href=#test-plan-3>Test plan</a></li></ul></li><li><a href=#teaching-plan-how-to-run-this-series-for-a-class>Teaching plan: how to run this series for a class</a><ul><li><a href=#recommended-pacing>Recommended pacing</a></li><li><a href=#how-to-evaluate-students>How to evaluate students</a></li></ul></li><li><a href=#exercises>Exercises</a><ul><li><a href=#how-to-test-your-answers>How to test your answers</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></div><h2 id=tldr>TL;DR</h2><ul><li>You’ll get hands-on capstone projects that combine the series skills: compiling RV32 C, inspecting ELF internals, understanding stack frames, debugging under QEMU, triaging firmware, and validating with hardware interfaces.</li><li>Each capstone includes a suggested deliverable, test plan, and “stretch goals”.</li><li>You’ll also get a study plan for teaching this material to others: how to run labs, evaluate exercises, and keep students moving.</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>If you’re teaching this to others, prioritize <strong>reproducibility</strong>: a student should be able to follow your steps on a clean machine and get the same results.</div><hr><h2 id=capstone-1-rv32-binaryisc---a-tiny-firmware-monitor-in-qemu>Capstone 1: RV32 “binaryISC” - a tiny firmware monitor in QEMU</h2><h3 id=goal>Goal</h3><p>Build a minimal bare-metal RV32 program that:</p><ul><li>starts at a known address (via linker script),</li><li>maintains a few global variables,</li><li>exposes a tiny “monitor loop” (even if it’s just a state machine),</li><li>and can be debugged deterministically.</li></ul><h3 id=deliverables>Deliverables</h3><ul><li><code>monitor.c</code>, <code>monitor.ld</code></li><li><code>monitor.elf</code>, <code>monitor.bin</code></li><li><code>monitor.map</code> (link map)</li><li>a short write-up:<ul><li>memory map (what is at which address)</li><li>how to connect with GDB and inspect state</li></ul></li></ul><h3 id=suggested-implementation-sketch>Suggested implementation sketch</h3><ul><li>A global command variable that changes state</li><li>A loop that checks the variable and updates a counter</li><li>Optionally: a “software breakpoint” label you can jump to</li></ul><h3 id=test-plan>Test plan</h3><ul><li>Verify <code>_start</code> address with <code>readelf -h</code> and <code>readelf -s</code>.</li><li>Verify <code>.text/.data/.bss</code> placement with the <code>.map</code> file.</li><li>Debug with <code>qemu-system-riscv32 -S -gdb tcp::1234</code> and GDB.</li></ul><h3 id=stretch-goals>Stretch goals</h3><ul><li>Add <code>.data</code> copy-down and <code>.bss</code> zeroing in startup code.</li><li>Add a basic UART output via QEMU virt UART (advanced).</li></ul><hr><h2 id=capstone-2-c--assembly-explanation-pack-teaching-deliverable>Capstone 2: “C → Assembly” explanation pack (teaching deliverable)</h2><h3 id=goal-1>Goal</h3><p>Create a set of teaching artifacts that explain how 5 small C functions compile to assembly at <code>-O0</code> and <code>-O2</code>.</p><p>Pick functions that cover:</p><ul><li>arithmetic + bitwise</li><li>if/else</li><li>loop over array</li><li>switch</li><li>a function call with stack frame</li></ul><h3 id=deliverables-1>Deliverables</h3><ul><li>a PDF or markdown write-up with:<ul><li>original C</li><li>disassembly excerpts</li><li>“how to read this” notes</li></ul></li><li>a short quiz for each function (students answer from disassembly)</li></ul><h3 id=test-plan-1>Test plan</h3><ul><li>For each function, include a GDB session snippet that confirms the behavior.</li></ul><hr><h2 id=capstone-3-firmware-triage-report-static-first>Capstone 3: Firmware triage report (static-first)</h2><h3 id=goal-2>Goal</h3><p>Take a firmware image (your own or a known training image) and produce a structured triage report.</p><h3 id=deliverables-2>Deliverables</h3><p>A report containing:</p><ul><li>file type identification results (<code>file</code>, entropy notes)</li><li>strings highlights and hypotheses</li><li>embedded artifacts found (ELF headers, compressed regions)</li><li>extracted sub-images (if applicable)</li><li>an initial memory map guess (for <code>.bin</code>)</li><li>next steps (which functions/subsystems to analyze)</li></ul><h3 id=test-plan-2>Test plan</h3><ul><li>Provide the exact commands used.</li><li>Provide offsets and hashes for extracted pieces.</li></ul><hr><h2 id=capstone-4-dynamic-analysis-mini-lab-frida>Capstone 4: Dynamic analysis mini-lab (Frida)</h2><h3 id=goal-3>Goal</h3><p>Hook a decision point in a userland program:</p><ul><li>log inputs</li><li>log outputs</li><li>optionally patch behavior</li></ul><h3 id=deliverables-3>Deliverables</h3><ul><li>Frida script(s)</li><li>before/after behavior evidence</li><li>explanation of why you chose that hook point</li></ul><h3 id=stretch-goals-1>Stretch goals</h3><ul><li>Convert to address-based hooking and handle stripped symbols.</li></ul><hr><h2 id=capstone-5-hardware-validation-worksheet-uartspii2c>Capstone 5: Hardware validation worksheet (UART/SPI/I2C)</h2><h3 id=goal-4>Goal</h3><p>Create a “field worksheet” that students can use on any board.</p><h3 id=deliverables-4>Deliverables</h3><p>A template that includes:</p><ul><li>power rails and expected voltages</li><li>ground points</li><li>suspected UART header pins and test results</li><li>suspected SPI flash chip ID, pin mapping, and sniff results</li><li>I2C scan plan and capture notes</li></ul><h3 id=test-plan-3>Test plan</h3><ul><li>Try it on a dev board you own and fill out a real worksheet.</li></ul><hr><h2 id=teaching-plan-how-to-run-this-series-for-a-class>Teaching plan: how to run this series for a class</h2><h3 id=recommended-pacing>Recommended pacing</h3><ul><li>Week 1: Chapters 1–3 (setup, ELF, ABI)</li><li>Week 2: Chapters 4–6 (optimization, control flow, stack)</li><li>Week 3: Chapters 7–9 (linker scripts, floats, debugging)</li><li>Week 4: Chapters 10–12 (firmware workflow, dynamic analysis, hardware interfaces)</li><li>Week 5+: Capstones</li></ul><h3 id=how-to-evaluate-students>How to evaluate students</h3><ul><li>Require “evidence artifacts”:<ul><li>map files, disassembly excerpts, GDB transcripts</li><li>small scripts (Python) that verify constants</li></ul></li><li>Use small oral checks:<ul><li>“show me where the return value is”</li><li>“show me which instruction loads struct field X”</li></ul></li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>A student who can explain one function’s stack frame clearly can usually generalize to many others.</div><hr><h2 id=exercises>Exercises</h2><ol><li>Choose one capstone and write a 1-page project plan with milestones.</li><li>Create a rubric for grading Capstone 2 (C→assembly explanation pack).</li><li>Write 10 “micro-questions” students can answer from <code>objdump</code> output.</li></ol><h3 id=how-to-test-your-answers>How to test your answers</h3><ul><li>If your plan has clear milestones, another student should be able to follow it.</li><li>If your rubric is specific, two graders should score similarly.</li></ul><hr><h2 id=summary>Summary</h2><p>You now have a set of realistic projects that combine the entire toolchain: compilation, ELF reading, assembly reasoning, stack/ABI understanding, debugging, firmware triage, and hardware interface validation.</p><p>If you want to expand this book next, the most valuable additions are:</p><ul><li>deeper startup/runtime topics (crt0 (C runtime zero) and initialization),</li><li>exception/trap handling on RISC-V,</li><li>and a full “emulated Linux firmware” lab with a filesystem and services.</li></ul><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/series/experimenting-with-risc-v/16-hardware-interfaces-uart-jtag-spi-i2c/ data-toggle=tooltip data-placement=top title="Interfaces in QEMU: UART and MMIO Concepts"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/series/experimenting-with-risc-v/18-summary/ data-toggle=tooltip data-placement=top title="Series Summary"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>