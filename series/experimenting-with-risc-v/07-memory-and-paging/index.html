<!doctype html><html lang=en-us data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Memory, Paging, and The Hardware Illusion - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Marcos Azevedo Blog"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Primary navigation"><a class="me-2 fs-4" href=/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Home</span>
</a><a class="mx-2 fs-4" href=/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Search</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Language><span class=fw-semibold>English</span>
<a href=/pt/series/experimenting-with-risc-v/07-memory-and-paging/>Português</a></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Memory, Paging, and The Hardware Illusion</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-24</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
6 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/memory title="tags: memory">memory</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/system-programming title="tags: system-programming">system-programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/qemu title="tags: qemu">qemu</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#1-the-notebook-analogy-what-is-a-page>1. The Notebook Analogy: What is a Page?</a></li><li><a href=#2-why-4kb-4096-bytes>2. Why 4KB (4096 bytes)?</a></li><li><a href=#3-the-grand-illusion-virtual-vs-physical>3. The Grand Illusion: Virtual vs. Physical</a><ul><li><a href=#the-programs-view-virtual-memory>The Program&rsquo;s View (Virtual Memory)</a></li><li><a href=#the-hardwares-view-physical-memory>The Hardware&rsquo;s View (Physical Memory)</a></li></ul></li><li><a href=#4-the-translator-page-tables>4. The Translator: Page Tables</a><ul><li><a href=#the-boss-register-satp>The &ldquo;Boss&rdquo; Register: <code>satp</code></a></li><li><a href=#the-speed-hack-tlb>The Speed Hack: TLB</a></li></ul></li><li><a href=#5-where-is-the-mmu-hardware-vs-kernel>5. Where is the MMU? (Hardware vs. Kernel)</a><ul><li><a href=#51-in-hardware-the-enforcer>5.1. In Hardware (The Enforcer)</a></li><li><a href=#52-in-kernelsoftware-the-manager>5.2. In Kernel/Software (The Manager)</a></li><li><a href=#53-summary>5.3. Summary</a></li></ul></li><li><a href=#6-kernel-vs-user-who-holds-the-keys>6. Kernel vs. User (Who holds the keys?)</a></li><li><a href=#7-summary>7. Summary</a></li></ul></nav></div><p>In the previous chapter, we saw something curious in the <code>readelf -l</code> output:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LOAD           ... RWE 0x1000
</span></span></code></pre></td></tr></table></div></div><p>And your linker script had this instruction:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>. = 0x80000000;
</span></span></code></pre></td></tr></table></div></div><p>Why <code>0x1000</code>? Why does the hardware care? And does your code <em>really</em> live at <code>0x80000000</code> inside the physical chip?
Let&rsquo;s pull back the curtain on one of the most important illusions in computer science: <strong>Memory Management</strong>.</p><h2 id=1-the-notebook-analogy-what-is-a-page>1. The Notebook Analogy: What is a Page?</h2><p>Imagine the memory (RAM) of your computer not as a &ldquo;giant bucket of billions of bytes&rdquo;, but as a <strong>Ring Binder Notebook</strong>.</p><ul><li>Each sheet of paper in this notebook is called a <strong>Page</strong>.</li><li>The processor doesn&rsquo;t manage memory byte-by-byte for everything; it prefers to move, protect, and map entire <strong>sheets</strong> (pages) at a time.</li></ul><p>This system is called <strong>Paging</strong>. It is how the hardware (specifically the <strong>MMU</strong> - Memory Management Unit) forces order onto the chaos of billions of memory cells.</p><h2 id=2-why-4kb-4096-bytes>2. Why 4KB (4096 bytes)?</h2><p>In the <code>readelf</code> output, we saw <code>Align 0x1000</code>. In decimal, <code>0x1000</code> is <strong>4096</strong>.
This is the standard size of one memory page. It became the industry standard (from the Intel 80386 and VAX days) because it sits in the <strong>&ldquo;Goldilocks Zone&rdquo;</strong>:</p><ol><li><p><strong>Not too small</strong>:
If pages were tiny (e.g., 100 bytes), your notebook would need <em>billions</em> of sheets. The &ldquo;Table of Contents&rdquo; (Page Table) needed to track them all would be gigantic, consuming more RAM than your actual programs!</p></li><li><p><strong>Not too big</strong>:
If pages were huge (e.g., 1MB), you would waste space. Imagine needing to store a tiny 1KB text file. The system would have to rip out a whole 1MB sheet just for that small note. The rest of the page would sit empty. This is called <strong>Internal Fragmentation</strong>.</p></li></ol><p><strong>4KB</strong> is the sweet spot: small enough to be efficient, big enough to manage easily.</p><p>This is why the linker aligns segments to <code>0x1000</code>: it is saying <strong>&ldquo;Start this section on a fresh new page.&rdquo;</strong></p><h2 id=3-the-grand-illusion-virtual-vs-physical>3. The Grand Illusion: Virtual vs. Physical</h2><p>Here is the secret: <strong>Your program is hallucinating.</strong></p><h3 id=the-programs-view-virtual-memory>The Program&rsquo;s View (Virtual Memory)</h3><p>Your program sees a perfect, contiguous block of memory.</p><ul><li>Page 1: <code>0x80000000</code> (Your Code)</li><li>Page 2: <code>0x80001000</code> (Your Data)</li><li>Page 3: <code>0x80002000</code> (Your Stack)</li></ul><p>&ldquo;Everything is neat, tidy, and right next to each other.&rdquo;</p><h3 id=the-hardwares-view-physical-memory>The Hardware&rsquo;s View (Physical Memory)</h3><p>The MMU takes those virtual pages and scatters them wherever there is free space on the actual RAM chips.</p><ul><li>Page 1 (Code) → Might be at Physical Address <code>0x9000F000</code> (near the end of the stick).</li><li>Page 2 (Data) → Might be at Physical Address <code>0x00004000</code> (right at the start).</li><li>Page 3 (Stack) → Might be at Physical Address <code>0x12345000</code> (somewhere in the middle).</li></ul><p>The hardware maintains this illusion so the OS can defragment memory without your program ever knowing.</p><h2 id=4-the-translator-page-tables>4. The Translator: Page Tables</h2><p>How does the CPU know that Virtual <code>0x80000000</code> is actually Physical <code>0x9000F000</code>?
It uses a look-up table called the <strong>Page Table</strong>, which lives in <strong>RAM (Physical Memory)</strong>.</p><table><thead><tr><th style=text-align:left>Virtual Page (What you see)</th><th style=text-align:left>Physical Page (Where it is)</th><th style=text-align:left>Permissions</th></tr></thead><tbody><tr><td style=text-align:left><strong>0x80000&mldr;</strong></td><td style=text-align:left>→ <strong>0x9000F&mldr;</strong></td><td style=text-align:left><strong>R-X</strong> (Read/Execute - Code)</td></tr><tr><td style=text-align:left><strong>0x80001&mldr;</strong></td><td style=text-align:left>→ <strong>0x00004&mldr;</strong></td><td style=text-align:left><strong>RW-</strong> (Read/Write - Data)</td></tr></tbody></table><h3 id=the-boss-register-satp>The &ldquo;Boss&rdquo; Register: <code>satp</code></h3><p>The CPU needs to know where this table lives. In RISC-V, this location is stored in a privileged register called <strong><code>satp</code></strong> (Supervisor Address Translation and Protection).
<em>(In x86, this is called <code>CR3</code>)</em>.</p><h3 id=the-speed-hack-tlb>The Speed Hack: TLB</h3><p>Reading this table from RAM for <em>every single instruction</em> would make the computer incredibly slow (it would double memory traffic).
To fix this, the CPU has a tiny, ultra-fast internal cache called the <strong>TLB</strong> (Translation Lookaside Buffer). It remembers recent translations:</p><blockquote><p>&ldquo;I just checked 0x80000&mldr;, it&rsquo;s at 0x9000F&mldr; Don&rsquo;t bother checking the RAM index again.&rdquo;</p></blockquote><h2 id=5-where-is-the-mmu-hardware-vs-kernel>5. Where is the MMU? (Hardware vs. Kernel)</h2><p>The <strong>MMU (Memory Management Unit)</strong> straddles the line between hardware and software. Here is exactly where it lives and who controls it:</p><h3 id=51-in-hardware-the-enforcer>5.1. In Hardware (The Enforcer)</h3><p>The MMU is a physical silicon circuit <strong>inside the CPU</strong> (or SoC).</p><ul><li><strong>Location</strong>: It sits between the CPU core (which executes instructions) and the memory bus (RAM).</li><li><strong>Job</strong>: It intercepts <em>every single memory address</em> the CPU tries to access. It automatically translates &ldquo;Virtual Address → Physical Address&rdquo; and checks permissions (Read/Write/Execute) purely in hardware, without slowing down the CPU.</li></ul><h3 id=52-in-kernelsoftware-the-manager>5.2. In Kernel/Software (The Manager)</h3><p>The MMU is &ldquo;dumb&rdquo; hardware that follows rules. The <strong>OS Kernel</strong> (Software) creates those rules.</p><ul><li><strong>Page Tables</strong>: The Kernel writes data structures (Page Tables) into RAM that map virtual addresses to physical ones.</li><li><strong>Control Registers</strong>: The Kernel tells the physical MMU where to find these tables by writing to a specific CPU register (e.g., <code>satp</code> on RISC-V, <code>CR3</code> on x86, or <code>TTBR</code> on ARM).</li></ul><h3 id=53-summary>5.3. Summary</h3><ul><li><strong>Hardware</strong>: usage → The MMU circuit performs the translation live.</li><li><strong>Kernel</strong>: setup → The OS fills out the &ldquo;forms&rdquo; (Page Tables) that the MMU reads.</li></ul><h2 id=6-kernel-vs-user-who-holds-the-keys>6. Kernel vs. User (Who holds the keys?)</h2><p>Can your program see the Page Tables? <strong>No.</strong></p><ul><li><p><strong>The Kernel (Ring 0 / Supervisor Mode)</strong>:
It <strong>owns</strong> the memory. It writes the Page Table into RAM and sets the <code>satp</code> register. It decides who lives where.
It <em>must</em> be able to read/write the table to launch programs.</p></li><li><p><strong>The User (Ring 3 / User Mode)</strong>:
It is just a tenant.</p><ul><li>If you try to read <code>satp</code>? <strong>Illegal Instruction Exception</strong>. The CPU crashes your program.</li><li>If you try to read the Page Table from RAM directly? <strong>Impossible</strong>.
Your program <strong>cannot</strong> issue physical addresses. It can only issue Virtual Addresses.
Even if you <em>know</em> the physical address is <code>0x9000F000</code>, if you try to read from <code>0x9000F000</code>, the MMU treats that as a <em>Virtual</em> address. <strong>Page Fault</strong>. The CPU sees you accessing memory you don&rsquo;t own and crashes your program. You are trapped in the Matrix.</li></ul></li></ul><h2 id=7-summary>7. Summary</h2><ol><li><strong>Pages</strong>: Memory is managed in 4KB &ldquo;sheets&rdquo;, not bytes.</li><li><strong>Alignment</strong>: Linkers aim for <code>0x1000</code> alignment to fit these pages perfectly.</li><li><strong>Virtual Memory</strong>: Programs see a simplified, contiguous fantasy.</li><li><strong>Physical Memory</strong>: The reality is scattered and fragmented.</li><li><strong>Page Tables</strong>: The dictionary mapping Fantasy → Reality, managed by the Kernel.</li><li><strong>MMU</strong>: The hardware circuit that intercepts every memory access and translates it.</li><li><strong>Kernel</strong>: The software that sets up the Page Tables and tells the MMU where to find them.</li></ol><p>This infrastructure is what allows multiple programs to run at once without crashing into each other. Each one gets its own private &ldquo;Notebook&rdquo; (Virtual Address Space), unaware that they are all sharing the same physical desk.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/series/experimenting-with-risc-v/06-elf-and-binutils/ data-toggle=tooltip data-placement=top title="ELF Internals and Binutils: Seeing What the Compiler Produced"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/series/experimenting-with-risc-v/08-rv32-abi-c-types/ data-toggle=tooltip data-placement=top title="RV32 ABI and C Data Types: Sizes, Alignment, and Layout"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>