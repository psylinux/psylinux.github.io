<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on Marcos Azevedo (aka psylinux)</title><link>https://psylinux.github.io/pt/categories/articles/</link><description>Recent content in Articles on Marcos Azevedo (aka psylinux)</description><generator>Hugo</generator><language>pt-br</language><copyright>2025 Marcos Azevedo</copyright><lastBuildDate>Sun, 13 Jan 2019 17:38:15 -0300</lastBuildDate><atom:link href="https://psylinux.github.io/pt/categories/articles/index.xml" rel="self" type="application/rss+xml"/><item><title>Artigo :: Debugando com strace</title><link>https://psylinux.github.io/pt/articles/article_debugging_with_strace/</link><pubDate>Sun, 13 Jan 2019 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/pt/articles/article_debugging_with_strace/</guid><description>&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>Ao final deste artigo, você entenderá como usar o strace para depurar programas sem acesso ao código-fonte, rastrear chamadas de sistema e solucionar problemas de execução no Linux.&lt;/p>
&lt;h2 id="visão-geral">Visão Geral&lt;/h2>
&lt;p>Depurar sem código-fonte pode parecer resolver um quebra-cabeça no escuro. O strace ilumina o caminho mostrando exatamente quais chamadas de sistema um programa faz, desde abertura de arquivos até conexões de rede. Se você está solucionando um crash, investigando comportamento suspeito, ou apenas curioso sobre como um programa funciona por baixo dos panos, o strace é uma ferramenta essencial no seu kit Linux.&lt;/p></description></item><item><title>Artigo :: Usando syscalls do Linux em Assembly</title><link>https://psylinux.github.io/pt/articles/article_linux_syscalls_in_assembly/</link><pubDate>Fri, 28 Dec 2018 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/pt/articles/article_linux_syscalls_in_assembly/</guid><description>&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>Este tutorial prático ensina como escrever programas assembly que invocam chamadas de sistema do Linux diretamente, ignorando a biblioteca C e interagindo com o kernel no nível mais baixo.&lt;/p>
&lt;h2 id="visão-geral">Visão Geral&lt;/h2>
&lt;p>Quando um programa precisa interagir com o sistema operacional; para escrever em um arquivo, alocar memória ou finalizar graciosamente; ele faz uma &lt;strong>chamada de sistema&lt;/strong> (syscall). A maioria dos programadores usa essas chamadas indiretamente através de wrappers da biblioteca C, mas entender como invocar syscalls diretamente do assembly te dá uma visão profunda de como programas realmente funcionam.&lt;/p></description></item><item><title>Artigo :: Começando com GDB</title><link>https://psylinux.github.io/pt/articles/article_getting_start_with_gdb/</link><pubDate>Sun, 16 Dec 2018 17:38:15 -0300</pubDate><guid>https://psylinux.github.io/pt/articles/article_getting_start_with_gdb/</guid><description>&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>Este guia completo cobre tudo o que você precisa para começar a depurar programas C com GDB, desde compilar com símbolos de depuração até inspecionar memória e controlar a execução do programa.&lt;/p>
&lt;h2 id="visão-geral">Visão Geral&lt;/h2>
&lt;p>GDB (GNU Debugger) é o depurador padrão para programas compilados com GCC. Ao contrário de ferramentas como strace que mostram chamadas de sistema, o GDB permite percorrer seu código-fonte linha por linha, inspecionar variáveis, definir breakpoints condicionais e até modificar o comportamento do programa durante a execução.&lt;/p></description></item></channel></rss>