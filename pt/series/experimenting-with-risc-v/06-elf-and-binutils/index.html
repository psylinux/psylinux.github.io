<!doctype html><html lang=pt-br data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Internals de ELF e Binutils: vendo o que o compilador produziu - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Blog do Marcos Azevedo"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Navegação principal"><a class="me-2 fs-4" href=/pt/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Início</span>
</a><a class="mx-2 fs-4" href=/pt/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/pt/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Buscar</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Idioma><a href=/series/experimenting-with-risc-v/06-elf-and-binutils/>English</a>
<span class=fw-semibold>Português</span></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Internals de ELF e Binutils: vendo o que o compilador produziu</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
10 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#1-tldr>1. TL;DR</a></li><li><a href=#2-pré-requisitos>2. Pré-requisitos</a></li><li><a href=#3-elf-em-um-diagrama>3. ELF em um diagrama</a></li><li><a href=#4-as-ferramentas-centrais-e-para-que-serve-cada-uma>4. As ferramentas “centrais” e para que serve cada uma</a><ul><li><a href=#41-readelf-estrutura>4.1. readelf (estrutura)</a></li><li><a href=#42-objdump-conteúdo>4.2. objdump (conteúdo)</a></li><li><a href=#43-nm-símbolos>4.3. nm (símbolos)</a></li><li><a href=#44-objcopy-transformação>4.4. objcopy (transformação)</a></li><li><a href=#45-xxd--hexdump-bytes-brutos>4.5. xxd / hexdump (bytes brutos)</a></li></ul></li><li><a href=#5-na-prática-inspecione-um-elf-bare-metal>5. Na prática: inspecione um ELF bare-metal</a><ul><li><a href=#51-compile-um-elf-de-exemplo>5.1. Compile um ELF de exemplo</a></li><li><a href=#52-mostre-o-header-elf>5.2. Mostre o header ELF</a></li><li><a href=#53-mostre-as-seções>5.3. Mostre as seções</a></li><li><a href=#54-mostre-os-segmentos-program-headers>5.4. Mostre os segmentos (program headers)</a></li></ul></li><li><a href=#6-onde-está-main-símbolos>6. Onde está main? (símbolos)</a><ul><li><a href=#61-rápido-nm>6.1. Rápido: nm</a></li><li><a href=#62-mais-completo-readelf--s>6.2. Mais completo: readelf -s</a></li></ul></li><li><a href=#7-disassembly-em-que-você-pode-confiar>7. Disassembly em que você pode confiar</a><ul><li><a href=#71-disassembly-básico>7.1. Disassembly básico</a></li><li><a href=#72-prefira-registradores-numéricos--sem-pseudo-instruções>7.2. Prefira: registradores numéricos + sem pseudo-instruções</a></li><li><a href=#73-encontre-uma-função-no-disassembly>7.3. Encontre uma função no disassembly</a></li></ul></li><li><a href=#8-relacione-instruções-com-bytes-workflow-de-hexdump>8. Relacione instruções com bytes (workflow de hexdump)</a><ul><li><a href=#81-passo-a-encontre-o-mapeamento-de-text>8.1. Passo A: encontre o mapeamento de .text</a></li><li><a href=#82-passo-b-calcule-um-offset-no-arquivo>8.2. Passo B: calcule um offset no arquivo</a></li><li><a href=#83-passo-c-visualize-os-bytes>8.3. Passo C: visualize os bytes</a></li></ul></li><li><a href=#9-relocações-endereços-ainda-não-finais>9. Relocações: “endereços ainda não finais”</a><ul><li><a href=#91-a-ideia-básica-com-um-modelo-mental>9.1. A ideia básica (com um modelo mental)</a></li><li><a href=#92-anatomia-de-uma-entrada-de-relocação>9.2. Anatomia de uma entrada de relocação</a></li><li><a href=#93-veja-relocações-em-um-o-real>9.3. Veja relocações em um <code>.o</code> real</a></li><li><a href=#94-o-que-acontece-depois-de-linkar>9.4. O que acontece depois de linkar?</a></li></ul></li><li><a href=#10-elf--binário-bruto-e-por-que-endereços-desaparecem>10. ELF → binário bruto (e por que endereços desaparecem)</a></li><li><a href=#11-exercícios>11. Exercícios</a><ul><li><a href=#111-como-testar-suas-respostas>11.1. Como testar suas respostas</a></li></ul></li><li><a href=#12-resumo>12. Resumo</a><ul><li><a href=#121-leia-a-seguir>12.1. Leia a seguir</a></li></ul></li></ul></nav></div><h2 id=1-tldr>1. TL;DR</h2><ul><li>Você vai aprender como um arquivo <strong>ELF (Executable and Linkable Format)</strong> é estruturado e como essa estrutura mapeia para a <strong>memória em runtime</strong>.</li><li>Vai praticar com <code>readelf</code>, <code>objdump</code>, <code>nm</code>, <code>objcopy</code>, <code>xxd</code> e <code>hexdump</code> para responder perguntas práticas:<ul><li>“Qual é o entry point?”</li><li>“Onde fica esta função?”</li><li>“Quais bytes correspondem a esta instrução?”</li><li>“Por que este endereço aparece no disassembly, mas não no arquivo?”</li></ul></li><li>Vai construir um modelo mental de <strong>seções vs segmentos</strong>, <strong>símbolos</strong> e <strong>relocações</strong>.</li></ul><p>Se você consegue ler a estrutura ELF com confiança, engenharia reversa e depuração ficam muito mais fáceis. Você para de chutar!</p><hr><h2 id=2-pré-requisitos>2. Pré-requisitos</h2><ul><li><code>riscv64-unknown-elf-gcc</code></li><li><code>readelf</code></li><li><code>objdump</code></li><li><code>nm</code></li><li><code>objcopy</code></li><li><code>xxd</code></li><li><code>hexdump</code></li></ul><h2 id=3-elf-em-um-diagrama>3. ELF em um diagrama</h2><p>Pense no ELF como tendo <strong>duas “visões” diferentes</strong> dos mesmos dados:</p><ul><li><strong>Seções</strong>: visão do desenvolvedor / linker (boa para símbolos, disassembly e análise estática)</li><li><strong>Segmentos</strong>: visão do loader (o que é mapeado na memória quando o programa roda)</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ELF file
</span></span><span style=display:flex><span> ├─ ELF header
</span></span><span style=display:flex><span> ├─ Program header table  (segments: loader view)
</span></span><span style=display:flex><span> │    ├─ PT_LOAD (text)
</span></span><span style=display:flex><span> │    ├─ PT_LOAD (data)
</span></span><span style=display:flex><span> │    └─ ...
</span></span><span style=display:flex><span> ├─ Section header table  (sections: linker view)
</span></span><span style=display:flex><span> │    ├─ .text
</span></span><span style=display:flex><span> │    ├─ .rodata
</span></span><span style=display:flex><span> │    ├─ .data
</span></span><span style=display:flex><span> │    ├─ .bss
</span></span><span style=display:flex><span> │    ├─ .symtab / .strtab
</span></span><span style=display:flex><span> │    └─ ...
</span></span><span style=display:flex><span> └─ Raw section contents
</span></span></code></pre></td></tr></table></div></div><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>Nem todos os ELFs incluem tabela de section headers (por exemplo, imagens stripadas ou embarcadas). Os program headers são o que os loaders realmente precisam.</div><h2 id=4-as-ferramentas-centrais-e-para-que-serve-cada-uma>4. As ferramentas “centrais” e para que serve cada uma</h2><h3 id=41-readelf-estrutura>4.1. readelf (estrutura)</h3><ul><li>Lê headers, seções, segmentos, símbolos, relocações.</li><li>Melhor ferramenta para responder “o que há dentro deste ELF?”</li></ul><h3 id=42-objdump-conteúdo>4.2. objdump (conteúdo)</h3><ul><li>Disassemble do código (<code>-d</code>)</li><li>Dump de bytes de seções (<code>-s</code>)</li><li>Mostra tabela de símbolos (<code>-t</code>)</li></ul><h3 id=43-nm-símbolos>4.3. nm (símbolos)</h3><ul><li>Lista rápida de “símbolos e endereços”</li></ul><h3 id=44-objcopy-transformação>4.4. objcopy (transformação)</h3><ul><li>Converte ELF → binário bruto (<code>-O binary</code>)</li><li>Extrai uma seção</li></ul><h3 id=45-xxd--hexdump-bytes-brutos>4.5. xxd / hexdump (bytes brutos)</h3><ul><li>Verifica hipóteses no nível de bytes (endianness, offsets)</li></ul><h2 id=5-na-prática-inspecione-um-elf-bare-metal>5. Na prática: inspecione um ELF bare-metal</h2><h3 id=51-compile-um-elf-de-exemplo>5.1. Compile um ELF de exemplo</h3><p>Vamos inspecionar um pequeno programa bare-metal que escreve na UART:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-gcc -O0 -g -ffreestanding -nostdlib <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -march<span style=color:#f92672>=</span>rv32im -mabi<span style=color:#f92672>=</span>ilp32 -T src/link.ld <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  src/start.s src/uart.c src/lab.c -o build/lab_rv32.elf
</span></span></code></pre></td></tr></table></div></div><h3 id=52-mostre-o-header-elf>5.2. Mostre o header ELF</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -h build/lab_rv32.elf
</span></span></code></pre></td></tr></table></div></div><p>Procure por:</p><ul><li><strong>Class</strong>: <code>ELF32</code></li><li><strong>Machine</strong>: <code>RISC-V</code></li><li><strong>Entry point address</strong>: a primeira instrução para onde o loader salta</li></ul><h3 id=53-mostre-as-seções>5.3. Mostre as seções</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -S build/lab_rv32.elf
</span></span></code></pre></td></tr></table></div></div><p>Campos importantes:</p><ul><li><strong>Name</strong>: por exemplo <code>.text</code>, <code>.rodata</code>, <code>.data</code>, <code>.bss</code></li><li><strong>Addr</strong>: endereço virtual (VMA (Virtual Memory Address) quando carregado)</li><li><strong>Off</strong>: offset no arquivo (onde os bytes vivem no arquivo)</li><li><strong>Size</strong>: tamanho da seção</li><li><strong>Flags</strong>: <code>AX</code> (alloc + execute), <code>WA</code> (write + alloc)</li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div><p>Quando você precisa mapear “este endereço em runtime” → “quais bytes no arquivo”, use:</p><p><code>file_offset = section_off + (address - section_addr)</code></p><p>Exemplo com <code>build/lab_rv32.elf</code> (de <code>readelf -S</code>):</p><ul><li><code>.text</code> tem <code>Addr=0x80000000</code> e <code>Off=0x001000</code></li><li>Se você quer o endereço em runtime <code>0x80000124</code> (o início de <code>uart_puthex32</code>):</li></ul><p><code>file_offset = 0x001000 + (0x80000124 - 0x80000000) = 0x001124</code></p><p>Como provar?</p><ul><li>Faça dump dos bytes no arquivo nesse offset:</li></ul><p><code>xxd -s 0x1124 -g 1 -l 16 build/lab_rv32.elf</code></p><ul><li>Compare com o disassembly naquele endereço:</li></ul><p><code>riscv64-unknown-elf-objdump -d -M numeric,no-aliases build/lab_rv32.elf | rg -n '80000124'</code></p><p>Sintaxe dos comandos:</p><ul><li><code>xxd -e -s 0x1124 -g 1 -l 16 build/lab_rv32.elf</code><ul><li><code>-e</code>: muda para modo little-endian</li><li><code>-s 0x1124</code>: faz seek para o offset <code>0x1124</code> a partir do início do arquivo</li><li><code>-g 1</code>: agrupa bytes em unidades de 1 byte</li><li><code>-l 16</code>: mostra 16 bytes</li></ul></li><li><code>riscv64-unknown-elf-objdump -d -M numeric,no-aliases build/lab_rv32.elf</code><ul><li><code>-d</code>: disassembly de todas as seções executáveis</li><li><code>-M numeric,no-aliases</code>: mostra registradores numéricos e evita aliases de pseudo-instruções</li></ul></li><li><code>rg -n '80000124'</code><ul><li><code>-n</code>: inclui números de linha na saída</li></ul></li></ul></div><h3 id=54-mostre-os-segmentos-program-headers>5.4. Mostre os segmentos (program headers)</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -l build/lab_rv32.elf
</span></span></code></pre></td></tr></table></div></div><p>Na lista de segmentos, foque em:</p><ul><li>segmentos <code>LOAD</code>: são mapeados na memória</li><li><code>VirtAddr</code> / <code>PhysAddr</code>: onde aparecem em runtime</li><li><code>FileSiz</code> / <code>MemSiz</code>: bytes no arquivo vs tamanho na memória</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div><code>.bss</code> normalmente tem <strong>zero bytes no arquivo</strong> (ela e “zero-inicializada” na memória). Por isso <code>MemSiz</code> pode ser maior que <code>FileSiz</code>.</div><h2 id=6-onde-está-main-símbolos>6. Onde está main? (símbolos)</h2><h3 id=61-rápido-nm>6.1. Rápido: nm</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nm -n build/lab_rv32.elf | grep -E <span style=color:#e6db74>&#39; main$| add_u32$&#39;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>-n</code> ordena por endereço</li><li>As letras do tipo de símbolo importam:<ul><li><code>T/t</code>: texto (código)</li><li><code>D/d</code>: dados inicializados</li><li><code>B/b</code>: BSS</li></ul></li></ul><h3 id=62-mais-completo-readelf--s>6.2. Mais completo: readelf -s</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -s build/lab_rv32.elf | grep -E <span style=color:#e6db74>&#39; main$| add_u32$| mmio_fake$&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>Você verá:</p><ul><li>valor do símbolo (endereço)</li><li>tamanho</li><li>binding (local/global)</li><li>índice da seção</li></ul><h2 id=7-disassembly-em-que-você-pode-confiar>7. Disassembly em que você pode confiar</h2><h3 id=71-disassembly-básico>7.1. Disassembly básico</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -d build/lab_rv32.elf | less
</span></span></code></pre></td></tr></table></div></div><h3 id=72-prefira-registradores-numéricos--sem-pseudo-instruções>7.2. Prefira: registradores numéricos + sem pseudo-instruções</h3><p>Pseudo-instruções podem esconder o que a CPU realmente executa.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -d -M numeric,no-aliases build/lab_rv32.elf | less
</span></span></code></pre></td></tr></table></div></div><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>Assembly RISC-V costuma ser mostrado com pseudo-instruções como <code>ret</code> (que na verdade é <code>jalr x0, x1, 0</code>). Ver a forma “real” ajuda na depuração.</div><h3 id=73-encontre-uma-função-no-disassembly>7.3. Encontre uma função no disassembly</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep -n <span style=color:#e6db74>&#34;&lt;add_u32&gt;&#34;</span> -n &lt;<span style=color:#f92672>(</span>riscv64-unknown-elf-objdump -d -M numeric,no-aliases build/lab_rv32.elf<span style=color:#f92672>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=8-relacione-instruções-com-bytes-workflow-de-hexdump>8. Relacione instruções com bytes (workflow de hexdump)</h2><p>Esta é uma habilidade prática de engenharia reversa:</p><ol><li>Identifique um endereço de instrução no <code>objdump</code>.</li><li>Converta esse endereço → offset no arquivo usando as infos da seção.</li><li>Inspecione os bytes brutos naquele offset.</li></ol><h3 id=81-passo-a-encontre-o-mapeamento-de-text>8.1. Passo A: encontre o mapeamento de .text</h3><p>Você quer o <strong>Addr</strong> e o <strong>Off</strong> da <code>.text</code>.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -S build/lab_rv32.elf | rg -n <span style=color:#e6db74>&#39;\.text&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>6:  <span style=color:#f92672>[</span> 1<span style=color:#f92672>]</span> .text   PROGBITS   <span style=color:#ae81ff>80000000</span> <span style=color:#ae81ff>001000</span> <span style=color:#ae81ff>000344</span> <span style=color:#ae81ff>00</span>  AX  <span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>4</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=82-passo-b-calcule-um-offset-no-arquivo>8.2. Passo B: calcule um offset no arquivo</h3><p>Primeiro, pegue o endereço de <code>main</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nm -n build/lab_rv32.elf | rg <span style=color:#e6db74>&#39; main$&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>80000280</span> T main
</span></span></code></pre></td></tr></table></div></div><p>Neste ELF, <code>main</code> está em <code>0x80000280</code>.<br>Pelos headers de seção, <code>.text</code> tem:</p><ul><li><code>Addr = 0x80000000</code></li><li><code>Off = 0x001000</code></li></ul><p>Então:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>offset = 0x001000 + (0x80000280 - 0x80000000)
</span></span><span style=display:flex><span>       = 0x001280
</span></span></code></pre></td></tr></table></div></div><p>Ou deixe o <code>bc</code> fazer a conta:</p><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>O <code>bc</code> é a calculadora padrão de linha de comando do Unix (suporta precisão arbitrária e diferentes bases numéricas).</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>bc -q <span style=color:#f92672>&lt;&lt;&lt;</span> <span style=color:#e6db74>&#39;obase=16; ibase=16; 001000 + (80000280 - 80000000)&#39;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1280</span>
</span></span></code></pre></td></tr></table></div></div><p>Notas sobre <code>bc</code>:</p><ul><li><code>ibase=16</code> faz o <code>bc</code> interpretar os números de entrada como hex.</li><li><code>obase=16</code> imprime o resultado em hex.</li><li>Defina <code>obase</code> <strong>antes</strong> de <code>ibase</code> para que <code>16</code> não seja interpretado como hex (<code>0x16</code>).</li><li>O resultado é <code>1280</code> em hex.</li></ul><h3 id=83-passo-c-visualize-os-bytes>8.3. Passo C: visualize os bytes</h3><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>Instruções RISC-V são little-endian na memória. A “ordem de bytes” que você vê no output do <code>objdump</code> é exatamente o que a CPU busca.</div><ol><li>Despeje os bytes da <code>.text</code> com <code>objdump</code>:</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -s -j .text build/lab_rv32.elf | head -n <span style=color:#ae81ff>20</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>build/lab_rv32.elf:     file format elf32-littleriscv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contents of section .text:
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000000</span> <span style=color:#ae81ff>17010001</span> <span style=color:#ae81ff>13010100</span> <span style=color:#ae81ff>93810100</span> <span style=color:#ae81ff>97020000</span>  ................
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000010</span> <span style=color:#ae81ff>93820235</span> <span style=color:#ae81ff>13834180</span> <span style=color:#ae81ff>63886200</span> 23a00200  ...5..A.c.b.#...
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000020</span> <span style=color:#ae81ff>93824200</span> e3cc62fe ef008025 <span style=color:#ae81ff>73005010</span>  ..B...b....%s.P.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000030</span> 6ff0dfff 130101fd <span style=color:#ae81ff>23268102</span> <span style=color:#ae81ff>13040103</span>  o.......#&amp;......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000040</span> 232ea4fc 8327c4fd 93f7f700 2326f4fe  <span style=color:#75715e>#....&#39;......#&amp;..</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000050</span> 0327c4fe <span style=color:#ae81ff>93079000</span> 63ece700 8327c4fe  .<span style=color:#e6db74>&#39;......c....&#39;</span>..
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000060</span> 93f7f70f <span style=color:#ae81ff>93870703</span> 93f7f70f 6f004001  ............o.@.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>80000070</span> 8327c4fe 93f7f70f <span style=color:#ae81ff>93877705</span> 93f7f70f  .<span style=color:#e6db74>&#39;........w.....
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 80000080 a305f4fe b7070010 0347b4fe 2380e700  .........G..#...
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 80000090 13000000 0324c102 13010103 67800000  .....$......g...
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 800000a0 130101fe 232e8100 13040102 93070500  ....#...........
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 800000b0 a307f4fe b7070010 0347f4fe 2380e700  .........G..#...
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 800000c0 13000000 0324c101 13010102 67800000  .....$......g...
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 800000d0 130101fe 232e1100 232c8100 13040102  ....#...#,......
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 800000e0 2326a4fe 6f00c001 8327c4fe 13871700  #&amp;..o....&#39;</span>......
</span></span><span style=display:flex><span> 800000f0 2326e4fe 83c70700 <span style=color:#ae81ff>13850700</span> eff05ffa  <span style=color:#75715e>#&amp;............_.</span>
</span></span></code></pre></td></tr></table></div></div><p>No output do <code>objdump -s</code>, o endereço à esquerda (por exemplo <code>0x800000d0</code>) é o <strong>endereço de runtime/VMA</strong> desses bytes quando <code>.text</code> é carregada na memória, <strong>não</strong> é um offset de arquivo. É o endereço base da seção somado ao offset dentro da seção.</p><ol start=2><li>Para inspecionar os bytes que correspondem especificamente a <code>main</code> (em <code>0x80000280</code> → offset de arquivo <code>0x1280</code>):</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>xxd -s 0x1280 -g <span style=color:#ae81ff>1</span> -l <span style=color:#ae81ff>16</span> build/lab_rv32.elf
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>00001280: <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>01</span> fe <span style=color:#ae81ff>23</span> 2e <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>23</span> 2c <span style=color:#ae81ff>81</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>02</span>  ....#...#,......
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>Qual é a visão equivalente no <code>xxd</code>/<code>hexdump</code>?</li></ol><p>O <code>objdump -j .text</code> encontra a seção <code>.text</code> pelo nome na tabela de seções do ELF e despeja os bytes que pertencem a ela. Já o <code>xxd</code> e o <code>hexdump</code> não conhecem seções; eles só despejam bytes crus a partir de um offset no arquivo. Neste ELF, a <code>.text</code> começa no <strong>offset de arquivo <code>0x1000</code></strong> (como visto nos headers de seção), então estes comandos são visões equivalentes dos mesmos bytes:</p><ul><li>Visão com <code>xxd</code>:</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>xxd -s 0x1000 -g <span style=color:#ae81ff>1</span> build/lab_rv32.elf | head -n <span style=color:#ae81ff>20</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Visão com <code>hexdump</code>:</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hexdump -C -s 0x1000 build/lab_rv32.elf | head -n <span style=color:#ae81ff>20</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Para verificar o offset do seu arquivo, confira a entrada <code>.text</code> nos headers de seção:</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -S build/lab_rv32.elf | rg <span style=color:#e6db74>&#39;\.text&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>Se o offset da <code>.text</code> for diferente, substitua <code>0x1000</code> por esse valor.</p><h2 id=9-relocações-endereços-ainda-não-finais>9. Relocações: “endereços ainda não finais”</h2><p>Uma <strong>relocação</strong> é uma nota do assembler para o linker dizendo:
“Eu tive que colocar <em>alguma coisa</em> nesta instrução ou dado, mas ainda não sei o endereço final. Conserte isso depois.”</p><p>Isso acontece porque arquivos <code>.o</code> são gerados <strong>antes</strong> do linker decidir onde tudo vai morar na memória.</p><h3 id=91-a-ideia-básica-com-um-modelo-mental>9.1. A ideia básica (com um modelo mental)</h3><p>Quando você escreve:</p><ul><li>uma chamada para uma função (<code>call foo</code>)</li><li>uma referência a um global (<code>la t0, global_var</code>)</li></ul><p>O assembler não sabe o endereço final de <code>foo</code> ou <code>global_var</code>.<br>Então ele:</p><ol><li>Emite um <strong>placeholder</strong> na instrução/dado,</li><li>Adiciona uma <strong>entrada de relocação</strong> que descreve como corrigir depois.</li></ol><p>Na linkedição, o linker lê essas entradas, calcula os endereços reais e reescreve os bytes.</p><h3 id=92-anatomia-de-uma-entrada-de-relocação>9.2. Anatomia de uma entrada de relocação</h3><p>Uma relocação normalmente inclui:</p><ul><li><strong>offset</strong>: onde, dentro da seção, aplicar o patch</li><li><strong>type</strong>: como aplicar (absoluta, PC‑relativa, par hi/lo, etc.)</li><li><strong>symbol</strong>: o alvo do patch</li><li><strong>addend</strong>: constante extra a somar (no RISC‑V costuma ser <strong>RELA</strong>, com o adendo/adicional explícito)</li></ul><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>Pense na relocação como uma receita: “pegue o endereço deste símbolo, aplique esta regra e escreva aqui.”</div><h3 id=93-veja-relocações-em-um-o-real>9.3. Veja relocações em um <code>.o</code> real</h3><p>Compile um arquivo objeto:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-gcc -O0 -g -ffreestanding -nostdlib -march<span style=color:#f92672>=</span>rv32im -mabi<span style=color:#f92672>=</span>ilp32 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c src/lab.c -o build/lab.o
</span></span></code></pre></td></tr></table></div></div><p>Inspecione as entradas:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -r build/lab.o
</span></span></code></pre></td></tr></table></div></div><p>Visões auxiliares úteis:</p><ol><li>Tabela de símbolos (nomes + endereços no .o)</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -s build/lab.o
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>Disassembly + relocações inline</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -dr build/lab.o
</span></span></code></pre></td></tr></table></div></div><p>O que observar em <code>readelf -r</code>:</p><ul><li><strong>Offset</strong>: a posição exata (em bytes) a ser patchada</li><li><strong>Info/Type</strong>: o tipo de relocação (específico da arquitetura)</li><li><strong>Symbol</strong>: o alvo (<code>foo</code>, <code>global_var</code>, etc.)</li><li><strong>Addend</strong>: o ajuste constante (quando presente)</li></ul><h3 id=94-o-que-acontece-depois-de-linkar>9.4. O que acontece depois de linkar?</h3><ul><li>Em um ELF <strong>totalmente linkado</strong> bare‑metal, a maioria das relocações é <strong>resolvida</strong> (os bytes já estão corrigidos).</li><li>Em um ELF <strong>dinâmico</strong>/compartilhado, algumas relocações ficam para o loader resolver em tempo de execução.</li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>Se você já se perguntou “como o linker conecta esta chamada àquela função?”, relocações são a resposta.</div><h2 id=10-elf--binário-bruto-e-por-que-endereços-desaparecem>10. ELF → binário bruto (e por que endereços desaparecem)</h2><p>Converta para binário flat:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objcopy -O binary build/lab_rv32.elf lab_rv32.bin
</span></span></code></pre></td></tr></table></div></div><p>Agora verifique:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l build/lab_rv32.elf lab_rv32.bin
</span></span></code></pre></td></tr></table></div></div><p>Por que o <code>.bin</code> é menor:</p><ul><li>Ele só contém <strong>bytes carregáveis</strong>; sem tabelas de símbolos nem headers de seção.</li></ul><div class="alert alert-warning my-4" role=alert><div class="fw-bold mb-2">Warning</div>Um <code>.bin</code> bruto <strong>não</strong> tem endereços inerentes. Você precisa saber (ou adivinhar) o endereço de carga a partir de um bootloader, mapa de memória ou firmware ao redor.</div><h2 id=11-exercícios>11. Exercícios</h2><ol><li>Use <code>readelf -h</code> para achar o <strong>entry point</strong> de <code>build/lab_rv32.elf</code>.</li><li>Use <code>nm -n</code> para achar o endereço de <code>add_u32</code> e localize-o no <code>objdump</code>.</li><li>Escolha uma instrução dentro de <code>add_u32</code> e encontre os bytes exatos no ELF usando o método de offset de seção.</li><li>Compile <code>lab.o</code> e liste relocações; explique em uma frase o que cada relocação tenta corrigir.</li></ol><h3 id=111-como-testar-suas-respostas>11.1. Como testar suas respostas</h3><ul><li>Você consegue apontar para um <strong>offset específico</strong> do arquivo que contém os bytes de uma instrução em um <strong>endereço virtual</strong> específico?</li><li>Você consegue explicar por que <code>.bss</code> tem tamanho na memória, mas não no arquivo?</li></ul><hr><h2 id=12-resumo>12. Resumo</h2><p>Você aprendeu a navegar pela estrutura ELF e usar binutils para conectar:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
  A[símbolos] --&gt; B[disassembly] --&gt; C[bytes brutos] --&gt; D[endereços em runtime]
</code></pre><h3 id=121-leia-a-seguir>12.1. Leia a seguir</h3><p>No output do <code>readelf -l</code>, você talvez tenha visto <code>Align 0x1000</code>. Por que o hardware se importa com esse número? E o seu código <em>realmente</em> vive em <code>0x80000000</code>?
Veja <strong><a href=/pt/series/experimenting-with-risc-v/07-memory-and-paging/>Capítulo 7: Memória, Paginação e a Ilusão do Hardware</a></strong> para descobrir os segredos da memória virtual.</p><p>A seguir: <strong>ABI do RV32 + tipos em C</strong>; vamos ligar layouts de dados em nível C (tamanhos, alinhamento, structs) aos loads/stores exatos que você vê no assembly.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/pt/series/experimenting-with-risc-v/05-basic-assembly/ data-toggle=tooltip data-placement=top title="Instruções básicas de assembly RISC-V"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/pt/series/experimenting-with-risc-v/07-memory-and-paging/ data-toggle=tooltip data-placement=top title="Memória, Paginação e a Ilusão do Hardware"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>