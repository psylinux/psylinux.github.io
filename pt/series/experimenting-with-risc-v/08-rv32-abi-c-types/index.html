<!doctype html><html lang=pt-br data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>ABI do RV32 e Tipos de Dados em C: Tamanhos, Alinhamento e Layout - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Blog do Marcos Azevedo"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Navegação principal"><a class="me-2 fs-4" href=/pt/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Início</span>
</a><a class="mx-2 fs-4" href=/pt/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/pt/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Buscar</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Idioma><a href=/series/experimenting-with-risc-v/08-rv32-abi-c-types/>English</a>
<span class=fw-semibold>Português</span></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>ABI do RV32 e Tipos de Dados em C: Tamanhos, Alinhamento e Layout</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
10 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#1-rv32-em-uma-frase>1. RV32 em uma frase</a><ul><li><a href=#flags-típicas-do-compilador>Flags típicas do compilador</a></li></ul></li><li><a href=#2-funções-dos-registradores-a-parte-que-você-precisa-memorizar>2. Funções dos registradores (a parte que você precisa memorizar)</a><ul><li><a href=#21-quem-preserva-o-quê-a-regra-da-responsabilidade>2.1. Quem preserva o quê? (A regra da &ldquo;responsabilidade&rdquo;)</a></li></ul></li><li><a href=#3-regras-da-pilha-a-segunda-parte-que-você-precisa-memorizar>3. Regras da pilha (a segunda parte que você precisa memorizar)</a><ul><li><a href=#31-a-pilha-cresce-para-baixo>3.1. A pilha cresce para baixo</a></li><li><a href=#32-alinhamento>3.2. Alinhamento</a></li></ul></li><li><a href=#4-tamanhos-de-tipos-c-no-rv32-ilp32>4. Tamanhos de tipos C no RV32 (ILP32)</a></li><li><a href=#5-na-prática-medir-tamanhos-e-alinhamento>5. Na prática: medir tamanhos e alinhamento</a><ul><li><a href=#51-o-que-você-deve-observar>5.1. O que você deve observar</a></li><li><a href=#52-mergulho-profundo-alinhamento-de-tipo-vs-alinhamento-da-pilha>5.2. Mergulho profundo: alinhamento de tipo vs. alinhamento da pilha</a></li></ul></li><li><a href=#6-padding-em-structs-explicado-com-diagrama>6. Padding em structs explicado (com diagrama)</a><ul><li><a href=#61-exemplo-struct-a>6.1. Exemplo: struct A</a></li><li><a href=#62-exemplo-complexo-misturando-char-int-long-long-long-double>6.2. Exemplo complexo: misturando char, int, long, long long, double</a></li></ul></li><li><a href=#7-endianness-e-o-que-isso-significa-para-c>7. Endianness e o que isso significa para C</a><ul><li><a href=#71-na-prática-confirmar-endianness>7.1. Na prática: confirmar endianness</a></li></ul></li><li><a href=#8-abi-encontra-o-assembly-parâmetros-e-valores-de-retorno>8. ABI encontra o assembly: parâmetros e valores de retorno</a></li><li><a href=#9-exercícios>9. Exercícios</a><ul><li><a href=#91-como-testar-suas-respostas>9.1. Como testar suas respostas</a></li></ul></li><li><a href=#10-resumo>10. Resumo</a></li></ul></nav></div><h2 id=tldr>TL;DR</h2><ul><li>Você vai aprender as regras do <strong>ABI RV32 ILP32 (Application Binary Interface)</strong> que fazem o C e o assembly &ldquo;concordarem&rdquo; sobre:<ul><li>uso de registradores,</li><li>passagem de parâmetros,</li><li>valores de retorno,</li><li>alinhamento da pilha,</li><li>e layout de dados.</li></ul></li><li>Você vai medir e verificar <strong>tamanhos de tipos</strong>, <strong>padding de structs</strong> e <strong>endianness</strong> no RV32.</li><li>Você vai produzir pequenos experimentos que pode inspecionar tanto em C quanto em assembly.</li></ul><p><strong>O ABI é o contrato. Se você violá-lo (mesmo sem querer), surgem “bugs estranhos” que parecem corrupção de pilha, ponteiros ruins ou travamentos aleatórios.</strong></p><hr><h2 id=1-rv32-em-uma-frase>1. RV32 em uma frase</h2><ul><li><strong>RV32</strong>: registradores e endereços são 32-bit.</li><li>ABI mais comum em ensino: <strong>ILP32 (Integer/Long/Pointer são 32-bit)</strong>.</li></ul><h3 id=flags-típicas-do-compilador>Flags típicas do compilador</h3><ul><li><code>-march=rv32im</code> (RV32I + multiply/divide)</li><li><code>-mabi=ilp32</code></li></ul><h2 id=2-funções-dos-registradores-a-parte-que-você-precisa-memorizar>2. Funções dos registradores (a parte que você precisa memorizar)</h2><p>RISC-V tem 32 registradores inteiros: <code>x0</code>..<code>x31</code>.</p><ul><li><code>x0</code>: sempre zero</li><li><code>x1</code>: <code>ra</code> (Return Address)</li><li><code>x2</code>: <code>sp</code> (Stack Pointer)</li><li><code>x3</code>: <code>gp</code> (Global Pointer)</li><li><code>x4</code>: <code>tp</code> (Thread Pointer)</li><li><code>x5</code>..<code>x7</code>: <code>t0</code>..<code>t2</code> (Temporários)</li><li><code>x8</code>: <code>s0/fp</code> (Saved / Frame Pointer)</li><li><code>x9</code>: <code>s1</code> (Saved)</li><li><code>x10</code>..<code>x17</code>: <code>a0</code>..<code>a7</code> (Argumentos / retornos)</li><li><code>x18</code>..<code>x27</code>: <code>s2</code>..<code>s11</code> (Saved)</li><li><code>x28</code>..<code>x31</code>: <code>t3</code>..<code>t6</code> (Temporários)</li></ul><h3 id=21-quem-preserva-o-quê-a-regra-da-responsabilidade>2.1. Quem preserva o quê? (A regra da &ldquo;responsabilidade&rdquo;)</h3><ul><li><p><strong>Caller-saved (registradores temporários <code>t*</code>, argumentos <code>a*</code>)</strong>:
São como &ldquo;rascunho&rdquo;. Se você (o <strong>caller</strong>) tem algo importante neles e chama outra função, <em>você</em> precisa salvá-los primeiro. A função chamada pode sobrescrevê-los sem pedir licença.</p></li><li><p><strong>Callee-saved (registradores salvos <code>s*</code>)</strong>:
São como &ldquo;ferramentas emprestadas&rdquo;. Se a função (o <strong>callee</strong>) quiser usá-los, ela deve devolvê-los exatamente como encontrou antes de retornar.</p></li><li><p><strong>Valor de retorno</strong>:
Por convenção, o resultado vai em <code>a0</code> (e <code>a1</code> se for 64-bit).</p></li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>Quando você lê um disassembly, a primeira pergunta é sempre: “este registrador deveria sobreviver a uma chamada?”</div><h2 id=3-regras-da-pilha-a-segunda-parte-que-você-precisa-memorizar>3. Regras da pilha (a segunda parte que você precisa memorizar)</h2><h3 id=31-a-pilha-cresce-para-baixo>3.1. A pilha cresce para baixo</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>high addresses
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>   registradores salvos
</span></span><span style=display:flex><span>   variáveis locais
</span></span><span style=display:flex><span>sp → topo atual da pilha
</span></span><span style=display:flex><span>low addresses
</span></span></code></pre></td></tr></table></div></div><h3 id=32-alinhamento>3.2. Alinhamento</h3><p>O ABI exige que o ponteiro de pilha (<code>sp</code>) esteja alinhado a <strong>16 bytes</strong> sempre que você chamar uma função.</p><p><strong>Por que 16 bytes? Por que não só 4?</strong>
Pense na pilha como um caminhão de entrega.</p><ul><li><strong>Eficiência</strong>: a CPU muitas vezes move dados em blocos de 128-bit (16 bytes) (para <strong>SIMD</strong> - <em>Single Instruction, Multiple Data</em> - operações vetoriais ou tipos <code>long double</code>). Se você estacionar o caminhão torto (desalinhado), a empilhadeira não consegue carregar o pallet de uma vez; ela precisa fazer duas cargas parciais.</li><li><strong>Prevenção de travamento</strong>: algumas instruções <em>crasham</em> se o endereço não for múltiplo de 16.</li></ul><p><strong>&ldquo;Nos limites de chamada&rdquo;</strong> significa:
Antes de saltar para uma nova função, você precisa garantir que <code>sp</code> seja múltiplo de 16. Se você empilhar 1 word (4 bytes), precisa adicionar 12 bytes de padding para que a próxima função comece alinhada em 16 bytes.</p><h2 id=4-tamanhos-de-tipos-c-no-rv32-ilp32>4. Tamanhos de tipos C no RV32 (ILP32)</h2><p>Estes são os tamanhos típicos (confirme na sua toolchain):</p><table><thead><tr><th style=text-align:right>Tipo C</th><th style=text-align:left>Bytes típicos (RV32 ILP32)</th></tr></thead><tbody><tr><td style=text-align:right><code>char</code></td><td style=text-align:left>1</td></tr><tr><td style=text-align:right><code>short</code></td><td style=text-align:left>2</td></tr><tr><td style=text-align:right><code>int</code></td><td style=text-align:left>4</td></tr><tr><td style=text-align:right><code>long</code></td><td style=text-align:left>4</td></tr><tr><td style=text-align:right><code>long long</code></td><td style=text-align:left>8</td></tr><tr><td style=text-align:right><code>void*</code></td><td style=text-align:left>4</td></tr><tr><td style=text-align:right><code>size_t</code></td><td style=text-align:left>4</td></tr><tr><td style=text-align:right><code>float</code></td><td style=text-align:left>4</td></tr><tr><td style=text-align:right><code>double</code></td><td style=text-align:left>8</td></tr></tbody></table><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>O padrão C não <em>garante</em> tamanhos exatos para muitos tipos (exceto mínimos). O ABI + convenção da plataforma determinam os tamanhos típicos.</div><h2 id=5-na-prática-medir-tamanhos-e-alinhamento>5. Na prática: medir tamanhos e alinhamento</h2><p>Crie:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/types.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;types.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;uart.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Compute the byte offset of a member inside a struct type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This does not access memory; it just uses the member&#39;s address from a null base.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define OFFSETOF(type, member) ((u32)(usize)&amp;(((type *)0)-&gt;member))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show_type</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, u32 size, u32 align) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Print a &#34;name size=... align=...&#34; line for one type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>uart_puts</span>(name);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; size=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(size);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; align=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(align);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Convenience macro: stringize the type name and show its size and alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define SHOW(T) show_type(#T, (u32)sizeof(T), (u32)_Alignof(T))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> A {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Likely introduces padding between fields due to alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  u8  a;
</span></span><span style=display:flex><span>  u32 b;
</span></span><span style=display:flex><span>  u16 c;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> B {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Same fields as A but reordered to reduce padding.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  u32 b;
</span></span><span style=display:flex><span>  u16 c;
</span></span><span style=display:flex><span>  u8  a;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Show basic scalar sizes/alignments for this target/compiler.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>char</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>short</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>float</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SHOW</span>(<span style=color:#66d9ef>double</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Compare layout of two structs with the same fields in different orders.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>struct A size=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>((u32)<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> A));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(a)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> A, a));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(b)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> A, b));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(c)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> A, c));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>struct B size=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>((u32)<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> B));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(b)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> B, b));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(c)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> B, c));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34; off(a)=&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putdec</span>(<span style=color:#a6e22e>OFFSETOF</span>(<span style=color:#66d9ef>struct</span> B, a));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_puts</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Compile e rode no QEMU:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-gcc -O0 -g -ffreestanding -nostdlib <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -march<span style=color:#f92672>=</span>rv32im -mabi<span style=color:#f92672>=</span>ilp32 -T src/link.ld <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  src/start.s src/uart.c src/types.c -o build/types_rv32.elf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>qemu-system-riscv32 -M virt -nographic -bios none -kernel build/types_rv32.elf
</span></span></code></pre></td></tr></table></div></div><h3 id=51-o-que-você-deve-observar>5.1. O que você deve observar</h3><ul><li>A tabela de <code>size</code> deve bater com as expectativas ILP32.</li><li><code>struct A</code> geralmente tem <strong>padding</strong> entre <code>a</code> e <code>b</code> para que <code>b</code> fique alinhado em 4 bytes.</li><li>Reordenar campos (<code>struct B</code>) costuma reduzir padding.</li></ul><h3 id=52-mergulho-profundo-alinhamento-de-tipo-vs-alinhamento-da-pilha>5.2. Mergulho profundo: alinhamento de tipo vs. alinhamento da pilha</h3><p>Você observou <code>double align=8</code>, mas o ABI exige que <code>sp</code> esteja alinhado em <strong>16 bytes</strong>. Essa confusão é comum. Vamos separar o <strong>Conteúdo</strong> do <strong>Contêiner</strong>.</p><h4 id=521-a-regra-do-conteúdo-alinhamento-de-tipo>5.2.1. A regra do conteúdo (alinhamento de tipo)</h4><p>Cada variável tem um &ldquo;alinhamento natural&rdquo;.</p><ul><li><code>char</code> (1 byte) pode morar em qualquer lugar (endereço divisível por 1).</li><li><code>int</code> (4 bytes) precisa morar em um endereço divisível por 4 (0x1000, 0x1004&mldr;).</li><li><code>double</code> (8 bytes) precisa morar em um endereço divisível por 8 (0x1000, 0x1008&mldr;).</li></ul><p>Se você violar isso, a CPU gera uma exceção de acesso desalinhado (ou faz uma leitura em duas partes, mais lenta).</p><h4 id=522-a-regra-do-contêiner-alinhamento-da-pilha>5.2.2. A regra do contêiner (alinhamento da pilha)</h4><p>O stack frame é o <strong>contêiner</strong> para todas essas variáveis locais.
Para ser um &ldquo;contêiner universal&rdquo;, a pilha precisa estar alinhada ao <strong>requisito mais estrito</strong> de qualquer variável que <em>possa</em> guardar.</p><ul><li>Se a pilha estivesse alinhada só em 4 bytes, ela poderia começar em <code>0x1004</code>.</li><li>Se você tentasse colocar um <code>double</code> (precisa de alinhamento 8) na pilha, poderia ser forçado a colocá-lo em <code>0x1004</code> relativo à memória 0, o que é <strong>ilegal</strong> para <code>double</code>.</li></ul><p><strong>A solução:</strong>
O ABI do RISC-V força a pilha a estar <strong>alinhada em 16 bytes</strong> (divisível por 16).
Como 16 é divisível por 1, 2, 4 e 8, um stack frame novo é <strong>garantido</strong> como ponto de partida seguro para <em>qualquer</em> tipo de dado padrão, incluindo vetores SIMD de 128-bit (<code>float128</code> ou <code>v128</code>), sem ajustes complexos.</p><h2 id=6-padding-em-structs-explicado-com-diagrama>6. Padding em structs explicado (com diagrama)</h2><h3 id=61-exemplo-struct-a>6.1. Exemplo: struct A</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> A {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span>  a; <span style=color:#75715e>// 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> b; <span style=color:#75715e>// precisa de alinhamento 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint16_t</span> c; <span style=color:#75715e>// 2 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></td></tr></table></div></div><p>Um layout comum em RV32:</p><p>Pense na memória como uma grade de palavras de 4 bytes (32-bit).</p><table><thead><tr><th style=text-align:left>Offset</th><th style=text-align:center>Byte 0</th><th style=text-align:center>Byte 1</th><th style=text-align:center>Byte 2</th><th style=text-align:center>Byte 3</th><th style=text-align:left>Conteúdo</th></tr></thead><tbody><tr><td style=text-align:left><strong>+0</strong></td><td style=text-align:center><code>a</code></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:left><code>a</code> ocupa 1 byte. Pulamos 3 bytes para a próxima linha começar alinhada.</td></tr><tr><td style=text-align:left><strong>+4</strong></td><td style=text-align:center><code>b</code></td><td style=text-align:center><code>b</code></td><td style=text-align:center><code>b</code></td><td style=text-align:center><code>b</code></td><td style=text-align:left><code>b</code> (4 bytes) encaixa perfeitamente em uma nova palavra.</td></tr><tr><td style=text-align:left><strong>+8</strong></td><td style=text-align:center><code>c</code></td><td style=text-align:center><code>c</code></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:left><code>c</code> (2 bytes) fica aqui. Preenchemos o final para alinhar o tamanho total da struct.</td></tr></tbody></table><h3 id=62-exemplo-complexo-misturando-char-int-long-long-long-double>6.2. Exemplo complexo: misturando char, int, long, long long, double</h3><p>Vamos ver uma struct usando todos os tipos que você perguntou, distinguindo <code>long</code> (32-bit) de <code>long long</code> (64-bit).</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Mixed {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> c;       <span style=color:#75715e>// 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> i;        <span style=color:#75715e>// 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> l;       <span style=color:#75715e>// 4 bytes (no RV32)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ll; <span style=color:#75715e>// 8 bytes (precisa de alinhamento 8)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> d;     <span style=color:#75715e>// 8 bytes (precisa de alinhamento 8)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></td></tr></table></div></div><p><strong>Análise de layout:</strong></p><ol><li><code>c</code> fica em <strong>+0</strong>.</li><li><code>i</code> precisa de alinhamento 4. O próximo slot disponível é +1, então pulamos 3 bytes. <code>i</code> começa em <strong>+4</strong>.</li><li><code>l</code> precisa de alinhamento 4. Ele encaixa perfeitamente em <strong>+8</strong>. Termina em +12.</li><li><code>ll</code> precisa de alinhamento 8. +12 não é divisível por 8 (12 % 8 = 4). Precisamos de 4 bytes de padding. <code>ll</code> começa em <strong>+16</strong>.</li><li><code>d</code> precisa de alinhamento 8. <code>ll</code> termina em +24. 24 é divisível por 8. <code>d</code> começa em <strong>+24</strong> imediatamente.</li></ol><p><strong>Grade de memória:</strong></p><table><thead><tr><th style=text-align:left>Offset</th><th style=text-align:center>Byte 0</th><th style=text-align:center>Byte 1</th><th style=text-align:center>Byte 2</th><th style=text-align:center>Byte 3</th><th style=text-align:left>Conteúdo</th></tr></thead><tbody><tr><td style=text-align:left><strong>+0</strong></td><td style=text-align:center><code>c</code></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:left>Alinhando para <code>i</code></td></tr><tr><td style=text-align:left><strong>+4</strong></td><td style=text-align:center><code>i</code></td><td style=text-align:center><code>i</code></td><td style=text-align:center><code>i</code></td><td style=text-align:center><code>i</code></td><td style=text-align:left></td></tr><tr><td style=text-align:left><strong>+8</strong></td><td style=text-align:center><code>l</code></td><td style=text-align:center><code>l</code></td><td style=text-align:center><code>l</code></td><td style=text-align:center><code>l</code></td><td style=text-align:left><code>long</code> tem 4 bytes no RV32</td></tr><tr><td style=text-align:left><strong>+12</strong></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:center><em>pad</em></td><td style=text-align:left>Alinhando para <code>ll</code> (precisa ser % 8)</td></tr><tr><td style=text-align:left><strong>+16</strong></td><td style=text-align:center><code>ll</code> (lo)</td><td style=text-align:center><code>ll</code></td><td style=text-align:center><code>ll</code></td><td style=text-align:center><code>ll</code></td><td style=text-align:left><code>long long</code> (primeira metade)</td></tr><tr><td style=text-align:left><strong>+20</strong></td><td style=text-align:center><code>ll</code> (hi)</td><td style=text-align:center><code>ll</code></td><td style=text-align:center><code>ll</code></td><td style=text-align:center><code>ll</code></td><td style=text-align:left><code>long long</code> (segunda metade)</td></tr><tr><td style=text-align:left><strong>+24</strong></td><td style=text-align:center><code>d</code> (lo)</td><td style=text-align:center><code>d</code></td><td style=text-align:center><code>d</code></td><td style=text-align:center><code>d</code></td><td style=text-align:left><code>double</code> (primeira metade)</td></tr><tr><td style=text-align:left><strong>+28</strong></td><td style=text-align:center><code>d</code> (hi)</td><td style=text-align:center><code>d</code></td><td style=text-align:center><code>d</code></td><td style=text-align:center><code>d</code></td><td style=text-align:left><code>double</code> (segunda metade)</td></tr></tbody></table><p><strong>Tamanho total:</strong> 32 bytes.</p><p>Por que o padding existe:</p><ul><li>Muitas CPUs carregam/armazenam de forma mais eficiente (ou só corretamente) quando alinhado.</li><li>O ABI escolhe regras que equilibram desempenho e compatibilidade.</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>Padding não é “espaço desperdiçado sem motivo”. É um contrato de desempenho + correção entre compilador e hardware.</div><h2 id=7-endianness-e-o-que-isso-significa-para-c>7. Endianness e o que isso significa para C</h2><p>A maioria dos alvos RV32 é <strong>little-endian</strong>.</p><p>Se você armazenar <code>0x11223344</code> na memória, os bytes aparecem como:</p><table><thead><tr><th style=text-align:left></th><th style=text-align:center></th><th style=text-align:center></th><th style=text-align:center></th><th style=text-align:center></th></tr></thead><tbody><tr><td style=text-align:left>address</td><td style=text-align:center>+0</td><td style=text-align:center>+1</td><td style=text-align:center>+2</td><td style=text-align:center>+3</td></tr><tr><td style=text-align:left>bytes</td><td style=text-align:center>44</td><td style=text-align:center>33</td><td style=text-align:center>22</td><td style=text-align:center>11</td></tr></tbody></table><h3 id=71-na-prática-confirmar-endianness>7.1. Na prática: confirmar endianness</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/endian.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;types.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;uart.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>puthex8</span>(u8 v) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Print one byte as two lowercase hex digits.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>digits <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0123456789abcdef&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putc</span>(digits[(v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0f</span>]);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>uart_putc</span>(digits[v <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0f</span>]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Store a known 32-bit pattern and examine its byte order in memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  u32 x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x11223344u</span>;
</span></span><span style=display:flex><span>  u8 <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> (u8 <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>x;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Emit the four bytes to reveal endianness (LSB first on little-endian).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>puthex8</span>(p[<span style=color:#ae81ff>0</span>]); <span style=color:#a6e22e>uart_putc</span>(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puthex8</span>(p[<span style=color:#ae81ff>1</span>]); <span style=color:#a6e22e>uart_putc</span>(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puthex8</span>(p[<span style=color:#ae81ff>2</span>]); <span style=color:#a6e22e>uart_putc</span>(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puthex8</span>(p[<span style=color:#ae81ff>3</span>]); <span style=color:#a6e22e>uart_putc</span>(<span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Compile/rode:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-gcc -O0 -g -ffreestanding -nostdlib <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -march<span style=color:#f92672>=</span>rv32im -mabi<span style=color:#f92672>=</span>ilp32 -T src/link.ld <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  src/start.s src/uart.c src/endian.c -o build/endian_rv32.elf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>qemu-system-riscv32 -M virt -nographic -bios none -kernel build/endian_rv32.elf
</span></span></code></pre></td></tr></table></div></div><h2 id=8-abi-encontra-o-assembly-parâmetros-e-valores-de-retorno>8. ABI encontra o assembly: parâmetros e valores de retorno</h2><p>Considere:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>add_u32</span>(<span style=color:#66d9ef>uint32_t</span> a, <span style=color:#66d9ef>uint32_t</span> b) { <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b; }
</span></span></code></pre></td></tr></table></div></div><p>No nível do ABI:</p><ul><li><code>a</code> chega em <code>a0</code></li><li><code>b</code> chega em <code>a1</code></li><li>valor de retorno volta em <code>a0</code></li></ul><p>No disassembly, você costuma ver:</p><ul><li>cálculo em um registrador</li><li>garantir que o resultado termine em <code>a0</code></li><li>retorno via <code>jalr</code> usando <code>ra</code></li></ul><h2 id=9-exercícios>9. Exercícios</h2><ol><li>Altere <code>struct A</code> adicionando um <code>uint8_t d;</code> no final. Preveja o novo tamanho <strong>antes</strong> de compilar.</li><li>Crie uma versão empacotada:<div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__attribute__</span>((packed)) P { u8 a; u32 b; };
</span></span></code></pre></td></tr></table></div></div></li><li>Compare <code>sizeof(struct P)</code> com a versão não empacotada.</li><li>Escreva uma função que retorne um <code>u64</code>. Observe quais registradores carregam o valor de retorno.</li></ol><div class="alert alert-warning my-4" role=alert><div class="fw-bold mb-2">Warning</div><code>__attribute__((packed))</code> pode causar <strong>acessos desalinhados</strong>. Algumas CPUs lidam com isso lentamente; outras podem falhar. Use structs empacotadas só quando você controla todo acesso e <em>precisa</em> de um layout exato (ex.: formatos de rede).</div><h3 id=91-como-testar-suas-respostas>9.1. Como testar suas respostas</h3><ul><li>Verifique tamanhos e offsets usando <code>sizeof</code> e o padrão do macro <code>OFFSETOF</code>.</li><li>Use <code>objdump -d -M numeric,no-aliases</code> para confirmar quais registradores são usados.</li></ul><h2 id=10-resumo>10. Resumo</h2><p>Você aprendeu o “contrato” do ABI RV32 ILP32: funções dos registradores, regras da pilha e como tipos C mapeiam para bytes.</p><p>A seguir: <strong>C → assembly + otimizações</strong> - você vai ver como <code>-O</code> muda o que aparece no disassembly, e como <code>volatile</code> realmente afeta o código gerado.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/pt/series/experimenting-with-risc-v/07-memory-and-paging/ data-toggle=tooltip data-placement=top title="Memória, Paginação e a Ilusão do Hardware"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/pt/series/experimenting-with-risc-v/09-c-to-asm-optimizations-volatile/ data-toggle=tooltip data-placement=top title="C → Assembly: Otimizações, Volatile e o que o compilador pode fazer"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>