<!doctype html><html lang=pt-br data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Triage de firmware e fluxo de engenharia reversa - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Blog do Marcos Azevedo"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Navegação principal"><a class="me-2 fs-4" href=/pt/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Início</span>
</a><a class="mx-2 fs-4" href=/pt/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/pt/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Buscar</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Idioma><a href=/series/experimenting-with-risc-v/14-firmware-triage-reverse-workflow/>English</a>
<span class=fw-semibold>Português</span></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Triage de firmware e fluxo de engenharia reversa</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
5 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#1-tipos-de-arquivos-de-firmware-o-que-você-pode-receber>1. Tipos de arquivos de firmware: o que você pode receber</a><ul><li><a href=#formatos-comuns>Formatos comuns</a></li><li><a href=#uma-realidade-central>Uma realidade central</a></li></ul></li><li><a href=#2-checklist-de-triagem-faça-sempre>2. Checklist de triagem (faça sempre)</a><ul><li><a href=#passo-1-identifique-o-tipo-de-arquivo>Passo 1: Identifique o tipo de arquivo</a></li><li><a href=#passo-2-entropiaestrutura-rápida>Passo 2: Entropia/estrutura rápida</a></li><li><a href=#passo-3-procure-assinaturas>Passo 3: Procure assinaturas</a></li><li><a href=#passo-4-se-for-elf-extraia-estrutura-imediatamente>Passo 4: Se for ELF: extraia estrutura imediatamente</a></li></ul></li><li><a href=#3-se-você-tem-um-bin-como-recuperar-um-endereço-de-carga-provável>3. Se você tem um .bin: como recuperar um endereço de carga provável</a><ul><li><a href=#estratégia-a-a-partir-do-mapa-de-memória-da-plataforma>Estratégia A: A partir do mapa de memória da plataforma</a></li><li><a href=#estratégia-b-vetores-de-reset--padrões-de-boot>Estratégia B: Vetores de reset / padrões de boot</a></li><li><a href=#estratégia-c-endereços-absolutos-no-código>Estratégia C: Endereços absolutos no código</a></li></ul></li><li><a href=#4-um-primeiro-disassembly-prático-sem-se-comprometer-cedo-demais>4. Um “primeiro disassembly” prático (sem se comprometer cedo demais)</a><ul><li><a href=#exemplo-disassemble-um-binário-bruto-como-rv32>Exemplo: disassemble um binário bruto como RV32</a></li></ul></li><li><a href=#5-carving-extraindo-sub-imagens-de-um-blob>5. Carving: extraindo sub-imagens de um blob</a></li><li><a href=#6-transforme-achados-em-um-mapa-habilidade-subestimada>6. Transforme achados em um mapa (habilidade subestimada)</a></li><li><a href=#7-laboratório-minimalista-de-estilo-firmware-usando-seu-próprio-sample>7. Laboratório minimalista de “estilo firmware” (usando seu próprio sample)</a></li><li><a href=#exercícios>Exercícios</a><ul><li><a href=#como-testar-suas-respostas>Como testar suas respostas</a></li></ul></li><li><a href=#resumo>Resumo</a></li></ul></nav></div><h2 id=tldr>TL;DR</h2><ul><li>Você vai aprender um fluxo prático para sair de um firmware desconhecido (<code>.bin</code>, <code>.img</code>, <code>.fw</code>, às vezes <code>.elf</code>) para um entendimento estruturado:<ul><li>identificar tipo de arquivo e arquitetura,</li><li>localizar limites entre código/dados,</li><li>recuperar endereços de carga e entry points,</li><li>e escolher as próximas ferramentas certas (disassembly, decompilação, emulação ou tracing no QEMU).</li></ul></li><li>Vai praticar etapas de <strong>triagem repetíveis</strong> que funcionam bem para alvos embarcados (incluindo RISC-V).</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>Engenharia reversa de firmware dá mais certo quando você trata o problema como uma investigação com checkpoints, e não como “clicar aleatoriamente em um disassembler”.</div><hr><h2 id=1-tipos-de-arquivos-de-firmware-o-que-você-pode-receber>1. Tipos de arquivos de firmware: o que você pode receber</h2><h3 id=formatos-comuns>Formatos comuns</h3><ul><li><strong>ELF</strong>: melhor cenário (símbolos, seções, entry point podem existir)</li><li><strong>Binário bruto (<code>.bin</code>)</strong>: bytes planos, sem endereços</li><li><strong>Imagens contêiner</strong>: podem embutir sistema de arquivos ou múltiplas partições (ex.: bundles de update)</li><li><strong>Blobs comprimidos</strong>: LZMA, gzip etc.</li></ul><h3 id=uma-realidade-central>Uma realidade central</h3><p>Um binário bruto <strong>não</strong> informa:</p><ul><li>onde ele carrega na memória</li><li>onde a execução começa</li><li>qual é a arquitetura</li></ul><p>Você precisa inferir isso pelo contexto.</p><hr><h2 id=2-checklist-de-triagem-faça-sempre>2. Checklist de triagem (faça sempre)</h2><h3 id=passo-1-identifique-o-tipo-de-arquivo>Passo 1: Identifique o tipo de arquivo</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>file firmware.bin
</span></span></code></pre></td></tr></table></div></div><p>Se for ELF, você está em situação muito mais fácil.</p><h3 id=passo-2-entropiaestrutura-rápida>Passo 2: Entropia/estrutura rápida</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hexdump -C firmware.bin | head
</span></span><span style=display:flex><span>strings -a firmware.bin | head
</span></span></code></pre></td></tr></table></div></div><p>Procure por:</p><ul><li>strings ASCII (mensagens de boot, paths, versões)</li><li>bytes mágicos (ex.: <code>7f 45 4c 46</code> para ELF)</li><li>longas sequências de <code>00</code> ou <code>ff</code> (geralmente padding/flash apagada)</li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>Se <code>strings</code> mostrar muitos paths legíveis como <code>/etc/</code> ou <code>/bin/</code>, você talvez esteja vendo uma imagem de filesystem Linux embarcado.</div><h3 id=passo-3-procure-assinaturas>Passo 3: Procure assinaturas</h3><p>Mesmo sem ferramentas especializadas, você pode buscar padrões:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep -aobU <span style=color:#e6db74>$&#39;\x7fELF&#39;</span> firmware.bin | head
</span></span></code></pre></td></tr></table></div></div><p>Isso indica se há um ELF embutido dentro de um blob maior.</p><h3 id=passo-4-se-for-elf-extraia-estrutura-imediatamente>Passo 4: Se for ELF: extraia estrutura imediatamente</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -h firmware.elf
</span></span><span style=display:flex><span>readelf -S firmware.elf
</span></span><span style=display:flex><span>readelf -l firmware.elf
</span></span><span style=display:flex><span>readelf -s firmware.elf | head
</span></span></code></pre></td></tr></table></div></div><p>Perguntas-chave:</p><ul><li>É <strong>ELF32</strong> ou <strong>ELF64</strong>?</li><li>Machine = <strong>RISC-V</strong>?</li><li>Qual é o <strong>entry point</strong>?</li><li>Quais segmentos são carregáveis (<code>PT_LOAD</code>)?</li></ul><hr><h2 id=3-se-você-tem-um-bin-como-recuperar-um-endereço-de-carga-provável>3. Se você tem um .bin: como recuperar um endereço de carga provável</h2><h3 id=estratégia-a-a-partir-do-mapa-de-memória-da-plataforma>Estratégia A: A partir do mapa de memória da plataforma</h3><p>Se você conhece o mapa de memória do alvo (por exemplo, QEMU <code>virt</code>), muitas vezes conhece endereços típicos de RAM/flash.</p><ul><li>Muitos exemplos RV32 bare-metal começam em <code>0x80000000</code> para RAM no QEMU virt.</li><li>SoCs reais variam bastante, use datasheets ou logs de boot.</li></ul><h3 id=estratégia-b-vetores-de-reset--padrões-de-boot>Estratégia B: Vetores de reset / padrões de boot</h3><p>Em algumas arquiteturas, o vetor de reset tem uma estrutura reconhecível. No RISC-V, o boot geralmente começa com um prólogo pequeno e um salto; os padrões são menos padronizados do que tabelas de vetor do ARM, mas você ainda pode procurar:</p><ul><li>sequências de prólogo plausíveis</li><li>referências a regiões MMIO conhecidas</li></ul><h3 id=estratégia-c-endereços-absolutos-no-código>Estratégia C: Endereços absolutos no código</h3><p>Se o firmware inclui endereços absolutos (registradores MMIO, ranges de RAM), esses endereços podem revelar a plataforma.</p><ul><li>Faça varredura por valores alinhados de 32 bits que parecem endereços (ex.: bits altos consistentes)</li></ul><div class="alert alert-info my-4" role=alert><div class="fw-bold mb-2">Note</div>É aqui que o conhecimento de ELF ajuda: uma vez que você chuta um endereço base, dá para testar se o disassembly “faz sentido”.</div><hr><h2 id=4-um-primeiro-disassembly-prático-sem-se-comprometer-cedo-demais>4. Um “primeiro disassembly” prático (sem se comprometer cedo demais)</h2><p>Mesmo sem uma ferramenta GUI, você pode fazer um disassembly sanity se souber a arquitetura.</p><h3 id=exemplo-disassemble-um-binário-bruto-como-rv32>Exemplo: disassemble um binário bruto como RV32</h3><p>Se você tem GNU binutils com suporte a RISC-V:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>riscv64-unknown-elf-objdump -D -b binary -m riscv:rv32 firmware.bin | less
</span></span></code></pre></td></tr></table></div></div><p>Se a saída for majoritariamente lixo/ilegais, suas suposições podem estar erradas:</p><ul><li>arquitetura errada (rv64 vs rv32)</li><li>endianness errado (raro em RISC-V)</li><li>endereço base errado (para branches relativos, isso importa)</li></ul><div class="alert alert-warning my-4" role=alert><div class="fw-bold mb-2">Warning</div><code>objdump -b binary</code> não sabe o endereço de carga correto. O disassembly é “endereçado” a partir de 0, a menos que você compense isso na sua ferramenta de análise.</div><hr><h2 id=5-carving-extraindo-sub-imagens-de-um-blob>5. Carving: extraindo sub-imagens de um blob</h2><p>Se você encontrar um ELF embutido no offset <code>O</code>, extraia:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>firmware.bin of<span style=color:#f92672>=</span>extracted.elf bs<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> skip<span style=color:#f92672>=</span>$O
</span></span><span style=display:flex><span>file extracted.elf
</span></span></code></pre></td></tr></table></div></div><p>Se for um ELF real, você pode usar todos os métodos do Capítulo 2.</p><p>Se você encontrar uma assinatura de filesystem ou compressão, pode precisar de ferramentas especializadas (comuns em firmware), mas o fluxo continua:</p><ul><li>identificar</li><li>extrair</li><li>validar</li></ul><hr><h2 id=6-transforme-achados-em-um-mapa-habilidade-subestimada>6. Transforme achados em um mapa (habilidade subestimada)</h2><p>Crie uma anotação simples como:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Firmware X
</span></span><span style=display:flex><span>- tamanho: ...
</span></span><span style=display:flex><span>- tipo: ...
</span></span><span style=display:flex><span>- possível arch: rv32im
</span></span><span style=display:flex><span>- strings: ...
</span></span><span style=display:flex><span>- endereço de carga suspeito: ...
</span></span><span style=display:flex><span>- entry point suspeito: ...
</span></span><span style=display:flex><span>- constantes notáveis: ...
</span></span><span style=display:flex><span>- próxima ação: (emular / disassemble / encontrar logs de UART / procurar formato de update)
</span></span></code></pre></td></tr></table></div></div><p>Isso torna seu trabalho reproduzível e mais fácil de compartilhar.</p><hr><h2 id=7-laboratório-minimalista-de-estilo-firmware-usando-seu-próprio-sample>7. Laboratório minimalista de “estilo firmware” (usando seu próprio sample)</h2><ol><li>Pegue <code>build/ld_demo.elf</code> (do Capítulo 7) e converta para <code>.bin</code>.</li><li>Finja que você não sabe o que é.</li><li>Use apenas <code>file</code>, <code>hexdump</code>, <code>strings</code> e <code>objdump -b binary</code> para identificar.</li><li>Escreva seu melhor palpite sobre:<ul><li>arquitetura,</li><li>endereço de carga,</li><li>o que o código faz.</li></ul></li></ol><p>Depois, compare com a verdade usando <code>readelf</code> no ELF original.</p><hr><h2 id=exercícios>Exercícios</h2><ol><li>Embuta um ELF em um blob maior (ex.: concatenando com padding) e pratique carving com <code>grep -aob</code> e <code>dd</code>.</li><li>Crie um binário bruto com um endereço base conhecido (ex.: seu linker origin) e veja como o disassembly muda se você assumir um base errado.</li><li>Escolha 5 strings de uma imagem de firmware e escreva hipóteses sobre a que subsistemas elas se relacionam.</li></ol><h3 id=como-testar-suas-respostas>Como testar suas respostas</h3><ul><li>Você consegue produzir um “mapa de análise” curto que outra pessoa conseguiria seguir.</li><li>Suas sub-imagens extraídas validam com <code>file</code> e <code>readelf</code> (quando aplicável).</li></ul><hr><h2 id=resumo>Resumo</h2><p>Você aprendeu um fluxo de triagem de firmware repetível: identificar → extrair → validar → mapear → escolher o próximo passo de análise.</p><p>A seguir: <strong>análise dinâmica com tracing no QEMU</strong>, quando isso se aplica a IoT/firmware, quais são as limitações e como fazer experimentos reprodutíveis e seguros.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/pt/series/experimenting-with-risc-v/13-floats-endianness-bitpacking/ data-toggle=tooltip data-placement=top title="Ponto flutuante, endianness e bit-packing (verificando com Python)"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/pt/series/experimenting-with-risc-v/15-dynamic-analysis-frida/ data-toggle=tooltip data-placement=top title="Análise dinâmica com tracing no QEMU"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>