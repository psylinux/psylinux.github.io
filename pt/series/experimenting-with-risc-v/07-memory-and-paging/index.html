<!doctype html><html lang=pt-br data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Memória, Paginação e a Ilusão do Hardware - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Blog do Marcos Azevedo"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Navegação principal"><a class="me-2 fs-4" href=/pt/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Início</span>
</a><a class="mx-2 fs-4" href=/pt/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/pt/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Buscar</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Idioma><a href=/series/experimenting-with-risc-v/07-memory-and-paging/>English</a>
<span class=fw-semibold>Português</span></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Memória, Paginação e a Ilusão do Hardware</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-24</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
5 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/memory title="tags: memory">memory</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/system-programming title="tags: system-programming">system-programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/qemu title="tags: qemu">qemu</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#1-a-analogia-do-caderno-o-que-é-uma-página>1. A analogia do caderno: o que é uma página?</a></li><li><a href=#2-por-que-4kb-4096-bytes>2. Por que 4KB (4096 bytes)?</a></li><li><a href=#3-a-grande-ilusão-virtual-vs-físico>3. A grande ilusão: virtual vs. físico</a><ul><li><a href=#a-visão-do-programa-memória-virtual>A visão do programa (Memória virtual)</a></li><li><a href=#a-visão-do-hardware-memória-física>A visão do hardware (Memória física)</a></li></ul></li><li><a href=#4-o-tradutor-tabelas-de-páginas>4. O tradutor: tabelas de páginas</a><ul><li><a href=#o-registrador-chefe-satp>O registrador &ldquo;chefe&rdquo;: <code>satp</code></a></li><li><a href=#o-truque-de-velocidade-tlb>O truque de velocidade: TLB</a></li></ul></li><li><a href=#5-onde-está-a-mmu-hardware-vs-kernel>5. Onde está a MMU? (Hardware vs. Kernel)</a><ul><li><a href=#51-no-hardware-o-executor>5.1. No hardware (o executor)</a></li><li><a href=#52-no-kernelsoftware-o-gerente>5.2. No kernel/software (o gerente)</a></li><li><a href=#53-resumo>5.3. Resumo</a></li></ul></li><li><a href=#6-kernel-vs-usuário-quem-segura-as-chaves>6. Kernel vs. usuário (Quem segura as chaves?)</a></li><li><a href=#7-resumo>7. Resumo</a></li></ul></nav></div><p>No capítulo anterior, vimos algo curioso no <code>readelf -l</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LOAD           ... RWE 0x1000
</span></span></code></pre></td></tr></table></div></div><p>E o seu linker script tinha esta instrução:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>. = 0x80000000;
</span></span></code></pre></td></tr></table></div></div><p>Por que <code>0x1000</code>? Por que o hardware se importa? E o seu código <em>realmente</em> vive em <code>0x80000000</code> dentro do chip físico?
Vamos levantar o véu de uma das ilusões mais importantes da ciência da computação: <strong>Gerenciamento de Memória</strong>.</p><h2 id=1-a-analogia-do-caderno-o-que-é-uma-página>1. A analogia do caderno: o que é uma página?</h2><p>Imagine a memória (RAM) do computador não como um &ldquo;balde gigante de bilhões de bytes&rdquo;, mas como um <strong>caderno de fichário</strong>.</p><ul><li>Cada folha desse caderno é chamada de <strong>Página</strong>.</li><li>O processador não gerencia memória byte a byte para tudo; ele prefere mover, proteger e mapear <strong>folhas</strong> (páginas) inteiras de uma vez.</li></ul><p>Esse sistema é chamado de <strong>Paginação (Paging)</strong>. É assim que o hardware (especificamente a <strong>MMU</strong> - Memory Management Unit) impõe ordem ao caos de bilhões de células de memória.</p><h2 id=2-por-que-4kb-4096-bytes>2. Por que 4KB (4096 bytes)?</h2><p>No <code>readelf</code>, vimos <code>Align 0x1000</code>. Em decimal, <code>0x1000</code> é <strong>4096</strong>.
Este é o tamanho padrão de uma página de memória. Virou padrão (desde os tempos do Intel 80386 e VAX) porque fica na <strong>&ldquo;zona de ouro&rdquo;</strong>:</p><ol><li><p><strong>Nem pequeno demais</strong>:
Se as páginas fossem minúsculas (ex.: 100 bytes), seu caderno precisaria de <em>bilhões</em> de folhas. A &ldquo;Tabela de Conteúdo&rdquo; (Page Table) que precisa rastrear tudo seria gigantesca, consumindo mais RAM do que seus programas!</p></li><li><p><strong>Nem grande demais</strong>:
Se as páginas fossem enormes (ex.: 1MB), você desperdiçaria espaço. Imagine precisar guardar um arquivo de texto de 1KB. O sistema teria que reservar uma folha inteira de 1MB só para aquela nota. O resto da página ficaria vazio. Isso se chama <strong>Fragmentação Interna</strong>.</p></li></ol><p><strong>4KB</strong> é o ponto de equilíbrio: pequeno o suficiente para ser eficiente, grande o bastante para gerenciar facilmente.</p><p>Por isso o linker alinha segmentos em <code>0x1000</code>: ele está dizendo <strong>&ldquo;Comece esta seção em uma página nova.&rdquo;</strong></p><h2 id=3-a-grande-ilusão-virtual-vs-físico>3. A grande ilusão: virtual vs. físico</h2><p>Aqui está o segredo: <strong>seu programa está alucinando</strong>.</p><h3 id=a-visão-do-programa-memória-virtual>A visão do programa (Memória virtual)</h3><p>Seu programa enxerga um bloco perfeito e contíguo de memória.</p><ul><li>Página 1: <code>0x80000000</code> (Seu código)</li><li>Página 2: <code>0x80001000</code> (Seus dados)</li><li>Página 3: <code>0x80002000</code> (Sua pilha)</li></ul><p>&ldquo;Tudo é limpo, organizado e lado a lado.&rdquo;</p><h3 id=a-visão-do-hardware-memória-física>A visão do hardware (Memória física)</h3><p>A MMU pega essas páginas virtuais e as espalha onde houver espaço livre nos chips de RAM.</p><ul><li>Página 1 (Código) → Pode estar no Endereço Físico <code>0x9000F000</code> (perto do fim do módulo).</li><li>Página 2 (Dados) → Pode estar no Endereço Físico <code>0x00004000</code> (bem no começo).</li><li>Página 3 (Pilha) → Pode estar no Endereço Físico <code>0x12345000</code> (em algum lugar no meio).</li></ul><p>O hardware mantém essa ilusão para que o SO possa desfragmentar a memória sem que o seu programa perceba.</p><h2 id=4-o-tradutor-tabelas-de-páginas>4. O tradutor: tabelas de páginas</h2><p>Como a CPU sabe que o Virtual <code>0x80000000</code> na verdade é Físico <code>0x9000F000</code>?
Ela usa uma tabela de consulta chamada <strong>Page Table</strong>, que fica na <strong>RAM (Memória Física)</strong>.</p><table><thead><tr><th style=text-align:left>Página Virtual (o que você vê)</th><th style=text-align:left>Página Física (onde está)</th><th style=text-align:left>Permissões</th></tr></thead><tbody><tr><td style=text-align:left><strong>0x80000&mldr;</strong></td><td style=text-align:left>→ <strong>0x9000F&mldr;</strong></td><td style=text-align:left><strong>R-X</strong> (Leitura/Execução - Código)</td></tr><tr><td style=text-align:left><strong>0x80001&mldr;</strong></td><td style=text-align:left>→ <strong>0x00004&mldr;</strong></td><td style=text-align:left><strong>RW-</strong> (Leitura/Escrita - Dados)</td></tr></tbody></table><h3 id=o-registrador-chefe-satp>O registrador &ldquo;chefe&rdquo;: <code>satp</code></h3><p>A CPU precisa saber onde essa tabela mora. Em RISC-V, essa localização fica num registrador privilegiado chamado <strong><code>satp</code></strong> (Supervisor Address Translation and Protection).
<em>(No x86, isso se chama <code>CR3</code>)</em>.</p><h3 id=o-truque-de-velocidade-tlb>O truque de velocidade: TLB</h3><p>Ler essa tabela na RAM para <em>cada instrução</em> deixaria o computador incrivelmente lento (dobraria o tráfego de memória).
Para corrigir isso, a CPU tem um cache interno minúsculo e ultra rápido chamado <strong>TLB</strong> (Translation Lookaside Buffer). Ele lembra traduções recentes:</p><blockquote><p>&ldquo;Acabei de verificar 0x80000&mldr;, é 0x9000F&mldr; Não precisa ir no índice da RAM de novo.&rdquo;</p></blockquote><h2 id=5-onde-está-a-mmu-hardware-vs-kernel>5. Onde está a MMU? (Hardware vs. Kernel)</h2><p>A <strong>MMU (Memory Management Unit)</strong> fica na fronteira entre hardware e software. Aqui está exatamente onde ela vive e quem a controla:</p><h3 id=51-no-hardware-o-executor>5.1. No hardware (o executor)</h3><p>A MMU é um circuito de silício <strong>dentro da CPU</strong> (ou SoC).</p><ul><li><strong>Localização</strong>: fica entre o núcleo da CPU (que executa instruções) e o barramento de memória (RAM).</li><li><strong>Trabalho</strong>: intercepta <em>todo endereço</em> que a CPU tenta acessar. Ela traduz automaticamente &ldquo;Endereço Virtual → Endereço Físico&rdquo; e checa permissões (Leitura/Escrita/Execução) em hardware, sem desacelerar a CPU.</li></ul><h3 id=52-no-kernelsoftware-o-gerente>5.2. No kernel/software (o gerente)</h3><p>A MMU é um hardware &ldquo;burro&rdquo; que segue regras. O <strong>Kernel do SO</strong> (software) cria essas regras.</p><ul><li><strong>Page Tables</strong>: o Kernel escreve estruturas de dados (Page Tables) na RAM que mapeiam endereços virtuais para físicos.</li><li><strong>Registradores de controle</strong>: o Kernel diz à MMU física onde encontrar essas tabelas escrevendo em um registrador específico da CPU (ex.: <code>satp</code> no RISC-V, <code>CR3</code> no x86, ou <code>TTBR</code> no ARM).</li></ul><h3 id=53-resumo>5.3. Resumo</h3><ul><li><strong>Hardware</strong>: uso → o circuito da MMU realiza a tradução em tempo real.</li><li><strong>Kernel</strong>: configuração → o SO preenche os &ldquo;formulários&rdquo; (Page Tables) que a MMU lê.</li></ul><h2 id=6-kernel-vs-usuário-quem-segura-as-chaves>6. Kernel vs. usuário (Quem segura as chaves?)</h2><p>Seu programa pode ver as Page Tables? <strong>Não.</strong></p><ul><li><p><strong>O Kernel (Ring 0 / Supervisor Mode)</strong>:
Ele <strong>possui</strong> a memória. Escreve a Page Table na RAM e configura o registrador <code>satp</code>. Ele decide quem vive onde.
Ele <em>precisa</em> poder ler/escrever a tabela para lançar programas.</p></li><li><p><strong>O Usuário (Ring 3 / User Mode)</strong>:
É só um inquilino.</p><ul><li>Se você tentar ler <code>satp</code>? <strong>Exceção de Instrução Ilegal</strong>. A CPU derruba seu programa.</li><li>Se você tentar ler a Page Table diretamente na RAM? <strong>Impossível</strong>.
Seu programa <strong>não consegue</strong> emitir endereços físicos. Ele só emite endereços virtuais.
Mesmo que você <em>saiba</em> que o endereço físico é <code>0x9000F000</code>, se tentar ler <code>0x9000F000</code>, a MMU trata isso como um endereço <em>virtual</em>. <strong>Page Fault</strong>. A CPU vê você acessando memória que não é sua e derruba seu programa. Você está preso na Matrix.</li></ul></li></ul><h2 id=7-resumo>7. Resumo</h2><ol><li><strong>Páginas</strong>: memória é gerenciada em &ldquo;folhas&rdquo; de 4KB, não em bytes.</li><li><strong>Alinhamento</strong>: o linker busca alinhamento em <code>0x1000</code> para encaixar páginas perfeitamente.</li><li><strong>Memória virtual</strong>: programas veem uma fantasia contígua e simplificada.</li><li><strong>Memória física</strong>: a realidade é espalhada e fragmentada.</li><li><strong>Page Tables</strong>: o dicionário que mapeia Fantasia → Realidade, gerenciado pelo Kernel.</li><li><strong>MMU</strong>: o circuito de hardware que intercepta todo acesso e traduz endereços.</li><li><strong>Kernel</strong>: o software que configura as Page Tables e diz à MMU onde achá-las.</li></ol><p>Essa infraestrutura é o que permite múltiplos programas rodarem ao mesmo tempo sem trombar uns nos outros. Cada um ganha seu próprio &ldquo;Caderno&rdquo; (Espaço de Endereços Virtual), sem perceber que todos compartilham a mesma mesa física.</p><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/pt/series/experimenting-with-risc-v/06-elf-and-binutils/ data-toggle=tooltip data-placement=top title="Internals de ELF e Binutils: vendo o que o compilador produziu"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/pt/series/experimenting-with-risc-v/08-rv32-abi-c-types/ data-toggle=tooltip data-placement=top title="ABI do RV32 e Tipos de Dados em C: Tamanhos, Alinhamento e Layout"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>