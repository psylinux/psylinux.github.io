<!doctype html><html lang=pt-br data-bs-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>Capstones e próximos passos - Marcos Azevedo (aka psylinux)</title><meta name=description content><meta name=author content="Blog do Marcos Azevedo"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/css/khata.css><link rel=stylesheet href=/css/code-highlight.css><script src=/js/khata.js></script><script src=/js/code-copy.js></script></head><body class="mx-auto text-white d-flex flex-column p-2"><nav aria-label="Navegação principal"><a class="me-2 fs-4" href=/pt/><i class="bi bi-house-door-fill" aria-hidden=true></i>
<span class=visually-hidden>Início</span>
</a><a class="mx-2 fs-4" href=/pt/menu><i class="bi bi-list" aria-hidden=true></i>
<span class=visually-hidden>Menu</span>
</a><a class="ms-2 fs-4" href=/pt/search><i class="bi bi-search" aria-hidden=true></i>
<span class=visually-hidden>Buscar</span></a><div class="language-switcher d-inline-flex align-items-center gap-2 ms-3" aria-label=Idioma><a href=/series/experimenting-with-risc-v/17-capstones-next-steps/>English</a>
<span class=fw-semibold>Português</span></div></nav><main class="flex-grow-1 d-flex flex-column"><article><h1 class=my-4>Capstones e próximos passos</h1><div class="metadata-panel p-2 mb-3 rounded border"><div class="metadata-value mb-1">Author: Marcos Azevedo</div><div class="metadata-value mb-1"><small>Date: <time>2026-01-20</time></small></div><div class="metadata-value mb-1"><small>Reading Time:
4 mins</small></div><div class="metadata-value mb-1"><small>Section:
<a href=/series title=Section>Series</a></small></div><div class="metadata-value mb-1"><small>Categories:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/categories/series title="categories: series">series</a></small></div><div class="metadata-value mb-1"><small>Tags:
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/c-lang title="tags: c-lang">c-lang</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/programming title="tags: programming">programming</a>
<a class="px-1 mx-1 rounded border border-secondary bg-taxa" href=/tags/risc-v title="tags: risc-v">risc-v</a></small></div></div><div class="TableOfContents border rounded p-2 ms-2 mb-2"><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#capstone-1-rv32-binaryisc---um-mini-monitor-de-firmware-no-qemu>Capstone 1: RV32 “binaryISC” - um mini monitor de firmware no QEMU</a><ul><li><a href=#objetivo>Objetivo</a></li><li><a href=#entregáveis>Entregáveis</a></li><li><a href=#esboço-sugerido-de-implementação>Esboço sugerido de implementação</a></li><li><a href=#plano-de-teste>Plano de teste</a></li><li><a href=#stretch-goals>Stretch goals</a></li></ul></li><li><a href=#capstone-2-c--assembly-pack-de-explicação-entregável-didático>Capstone 2: “C → Assembly” pack de explicação (entregável didático)</a><ul><li><a href=#objetivo-1>Objetivo</a></li><li><a href=#entregáveis-1>Entregáveis</a></li><li><a href=#plano-de-teste-1>Plano de teste</a></li></ul></li><li><a href=#capstone-3-relatório-de-triagem-de-firmware-estático-primeiro>Capstone 3: Relatório de triagem de firmware (estático primeiro)</a><ul><li><a href=#objetivo-2>Objetivo</a></li><li><a href=#entregáveis-2>Entregáveis</a></li><li><a href=#plano-de-teste-2>Plano de teste</a></li></ul></li><li><a href=#capstone-4-mini-lab-de-análise-dinâmica-frida>Capstone 4: Mini-lab de análise dinâmica (Frida)</a><ul><li><a href=#objetivo-3>Objetivo</a></li><li><a href=#entregáveis-3>Entregáveis</a></li><li><a href=#stretch-goals-1>Stretch goals</a></li></ul></li><li><a href=#capstone-5-planilha-de-validação-de-hardware-uartspii2c>Capstone 5: Planilha de validação de hardware (UART/SPI/I2C)</a><ul><li><a href=#objetivo-4>Objetivo</a></li><li><a href=#entregáveis-4>Entregáveis</a></li><li><a href=#plano-de-teste-3>Plano de teste</a></li></ul></li><li><a href=#plano-de-ensino-como-rodar-esta-série-para-uma-turma>Plano de ensino: como rodar esta série para uma turma</a><ul><li><a href=#ritmo-recomendado>Ritmo recomendado</a></li><li><a href=#como-avaliar-alunos>Como avaliar alunos</a></li></ul></li><li><a href=#exercícios>Exercícios</a><ul><li><a href=#como-testar-suas-respostas>Como testar suas respostas</a></li></ul></li><li><a href=#resumo>Resumo</a></li></ul></nav></div><h2 id=tldr>TL;DR</h2><ul><li>Você vai ter projetos capstone práticos que combinam as habilidades da série: compilar C RV32, inspecionar internals de ELF, entender stack frames, depurar no QEMU, fazer triagem de firmware e validar com interfaces de hardware.</li><li>Cada capstone inclui entregáveis sugeridos, plano de teste e “stretch goals”.</li><li>Você também recebe um plano de estudo para ensinar este material a outras pessoas: como conduzir labs, avaliar exercícios e manter os alunos avançando.</li></ul><div class="alert alert-danger my-4" role=alert><div class="fw-bold mb-2">Important</div>Se você estiver ensinando isso para outros, priorize <strong>reprodutibilidade</strong>: um aluno deve conseguir seguir seus passos em uma máquina limpa e obter os mesmos resultados.</div><hr><h2 id=capstone-1-rv32-binaryisc---um-mini-monitor-de-firmware-no-qemu>Capstone 1: RV32 “binaryISC” - um mini monitor de firmware no QEMU</h2><h3 id=objetivo>Objetivo</h3><p>Construir um programa bare-metal RV32 mínimo que:</p><ul><li>começa em um endereço conhecido (via linker script),</li><li>mantém algumas variáveis globais,</li><li>expõe um pequeno “monitor loop” (mesmo que seja apenas uma máquina de estados),</li><li>e possa ser depurado de forma determinística.</li></ul><h3 id=entregáveis>Entregáveis</h3><ul><li><code>monitor.c</code>, <code>monitor.ld</code></li><li><code>monitor.elf</code>, <code>monitor.bin</code></li><li><code>monitor.map</code> (link map)</li><li>um write-up curto:<ul><li>mapa de memória (o que está em qual endereço)</li><li>como conectar com GDB e inspecionar estado</li></ul></li></ul><h3 id=esboço-sugerido-de-implementação>Esboço sugerido de implementação</h3><ul><li>Uma variável global de comando que muda de estado</li><li>Um loop que checa a variável e atualiza um contador</li><li>Opcional: um rótulo de “software breakpoint” para o qual você pode saltar</li></ul><h3 id=plano-de-teste>Plano de teste</h3><ul><li>Verificar o endereço de <code>_start</code> com <code>readelf -h</code> e <code>readelf -s</code>.</li><li>Verificar posicionamento de <code>.text/.data/.bss</code> com o arquivo <code>.map</code>.</li><li>Depurar com <code>qemu-system-riscv32 -S -gdb tcp::1234</code> e GDB.</li></ul><h3 id=stretch-goals>Stretch goals</h3><ul><li>Adicionar copy-down de <code>.data</code> e zero de <code>.bss</code> no startup.</li><li>Adicionar saída UART básica via QEMU virt UART (avançado).</li></ul><hr><h2 id=capstone-2-c--assembly-pack-de-explicação-entregável-didático>Capstone 2: “C → Assembly” pack de explicação (entregável didático)</h2><h3 id=objetivo-1>Objetivo</h3><p>Criar um conjunto de materiais didáticos que explicam como 5 funções C pequenas compilam para assembly em <code>-O0</code> e <code>-O2</code>.</p><p>Escolha funções que cubram:</p><ul><li>aritmética + bitwise</li><li>if/else</li><li>loop sobre array</li><li>switch</li><li>chamada de função com stack frame</li></ul><h3 id=entregáveis-1>Entregáveis</h3><ul><li>um PDF ou write-up em markdown com:<ul><li>C original</li><li>trechos de disassembly</li><li>notas de “como ler isso”</li></ul></li><li>um quiz curto para cada função (alunos respondem a partir do disassembly)</li></ul><h3 id=plano-de-teste-1>Plano de teste</h3><ul><li>Para cada função, inclua um trecho de sessão GDB que confirme o comportamento.</li></ul><hr><h2 id=capstone-3-relatório-de-triagem-de-firmware-estático-primeiro>Capstone 3: Relatório de triagem de firmware (estático primeiro)</h2><h3 id=objetivo-2>Objetivo</h3><p>Pegar uma imagem de firmware (sua ou de treinamento) e produzir um relatório estruturado de triagem.</p><h3 id=entregáveis-2>Entregáveis</h3><p>Um relatório contendo:</p><ul><li>resultados de identificação de tipo (<code>file</code>, notas de entropia)</li><li>destaques de strings e hipóteses</li><li>artefatos embutidos encontrados (headers ELF, regiões comprimidas)</li><li>sub-imagens extraídas (se aplicável)</li><li>um palpite inicial de mapa de memória (para <code>.bin</code>)</li><li>próximos passos (quais funções/subsistemas analisar)</li></ul><h3 id=plano-de-teste-2>Plano de teste</h3><ul><li>Forneça os comandos exatos usados.</li><li>Forneça offsets e hashes para as partes extraídas.</li></ul><hr><h2 id=capstone-4-mini-lab-de-análise-dinâmica-frida>Capstone 4: Mini-lab de análise dinâmica (Frida)</h2><h3 id=objetivo-3>Objetivo</h3><p>Hookar um ponto de decisão em um programa userland:</p><ul><li>logar entradas</li><li>logar saídas</li><li>opcionalmente patchar o comportamento</li></ul><h3 id=entregáveis-3>Entregáveis</h3><ul><li>scripts Frida</li><li>evidências de comportamento antes/depois</li><li>explicação de por que você escolheu aquele ponto de hook</li></ul><h3 id=stretch-goals-1>Stretch goals</h3><ul><li>Converter para hook baseado em endereço e lidar com símbolos stripados.</li></ul><hr><h2 id=capstone-5-planilha-de-validação-de-hardware-uartspii2c>Capstone 5: Planilha de validação de hardware (UART/SPI/I2C)</h2><h3 id=objetivo-4>Objetivo</h3><p>Criar uma “planilha de campo” que alunos possam usar em qualquer placa.</p><h3 id=entregáveis-4>Entregáveis</h3><p>Um template que inclua:</p><ul><li>trilhas de alimentação e tensões esperadas</li><li>pontos de ground</li><li>pinos de header UART suspeitos e resultados de teste</li><li>ID de chip SPI flash suspeito, mapeamento de pinos e resultados de sniff</li><li>plano de varredura I2C e notas de captura</li></ul><h3 id=plano-de-teste-3>Plano de teste</h3><ul><li>Teste em uma placa dev que você possui e preencha uma planilha real.</li></ul><hr><h2 id=plano-de-ensino-como-rodar-esta-série-para-uma-turma>Plano de ensino: como rodar esta série para uma turma</h2><h3 id=ritmo-recomendado>Ritmo recomendado</h3><ul><li>Semana 1: Capítulos 1–3 (setup, ELF, ABI)</li><li>Semana 2: Capítulos 4–6 (otimização, fluxo de controle, stack)</li><li>Semana 3: Capítulos 7–9 (linker scripts, floats, debug)</li><li>Semana 4: Capítulos 10–12 (workflow de firmware, análise dinâmica, interfaces de hardware)</li><li>Semana 5+: Capstones</li></ul><h3 id=como-avaliar-alunos>Como avaliar alunos</h3><ul><li>Exigir “artefatos de evidência”:<ul><li>map files, trechos de disassembly, transcrições de GDB</li><li>pequenos scripts (Python) que validam constantes</li></ul></li><li>Usar checagens orais curtas:<ul><li>“me mostre onde o valor de retorno está”</li><li>“me mostre qual instrução carrega o campo X da struct”</li></ul></li></ul><div class="alert alert-success my-4" role=alert><div class="fw-bold mb-2">Tip</div>Um aluno que consegue explicar claramente o stack frame de uma função costuma generalizar isso para várias outras.</div><hr><h2 id=exercícios>Exercícios</h2><ol><li>Escolha um capstone e escreva um plano de projeto de 1 página com marcos.</li><li>Crie uma rubrica para corrigir o Capstone 2 (pack de explicação C→assembly).</li><li>Escreva 10 “micro-perguntas” que alunos possam responder a partir de output do <code>objdump</code>.</li></ol><h3 id=como-testar-suas-respostas>Como testar suas respostas</h3><ul><li>Se o seu plano tem marcos claros, outro aluno deve conseguir segui-lo.</li><li>Se sua rubrica é específica, dois avaliadores devem pontuar de forma similar.</li></ul><hr><h2 id=resumo>Resumo</h2><p>Agora você tem um conjunto de projetos realistas que combinam toda a toolchain: compilação, leitura de ELF, raciocínio em assembly, entendimento de stack/ABI, depuração, triagem de firmware e validação de interfaces de hardware.</p><p>Se você quiser expandir este livro depois, as adições mais valiosas são:</p><ul><li>tópicos mais profundos de startup/runtime (crt0 (C runtime zero) e inicialização),</li><li>tratamento de exceções/traps no RISC-V,</li><li>e um lab completo de “firmware Linux emulado” com filesystem e serviços.</li></ul><div class=mt-4><script src=https://giscus.app/client.js data-repo=psylinux/psylinux.github.io data-repo-id=R_kgDORCdA4Q data-category=Comments data-category-id=DIC_kwDORCdA4c4C1fwh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><div class=footer><div class="mb-4 d-flex flex-row justify-content-around"><div class=mr-4><a href=/pt/series/experimenting-with-risc-v/16-hardware-interfaces-uart-jtag-spi-i2c/ data-toggle=tooltip data-placement=top title="Interfaces no QEMU: UART e conceitos de MMIO"><i class="bi bi-chevron-left" style=font-size:2em></i></a></div><div class=ms-4><a href=/pt/series/experimenting-with-risc-v/18-summary/ data-toggle=tooltip data-placement=top title="Resumo da série"><i class="bi bi-chevron-right" style=font-size:2em></i></a></div></div><footer class="border-top border-light py-2 d-flex flex-row flex-wrap justify-content-between"><div class=copyright><small>psylinux</small></div><div><small>Copyrighted © Marcos Azevedo, 2025.</small></div></footer><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b1b9cb012238436c9efbac840abc1907"}'></script></div></body></html>